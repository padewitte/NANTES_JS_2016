{"version":3,"sources":["myscript.js","MyScript.js","point.js","quadraticPoint.js","rectangle.js","inkManager.js","penParameters.js","renderingParameters.js","mathUtils.js","abstractWSMessage.js","abstractComponent.js","stroke.js","strokeComponent.js","characterInputComponent.js","characterInputComponentAlternate.js","abstractParameter.js","abstractRecognitionInput.js","abstractRecognitionData.js","recognitionLanguagesData.js","abstractStartRequestWSMessage.js","abstractContinueRequestWSMessage.js","challengeRequestWSMessage.js","initRequestWSMessage.js","resetRequestWSMessage.js","abstractTextInputComponent.js","charInputComponent.js","stringInputComponent.js","textInputUnit.js","textParameter.js","textProperties.js","textRecognitionInput.js","textRecognitionData.js","textStartRequestWSMessage.js","textContinueRequestWSMessage.js","shapeParameter.js","shapeRecognitionInput.js","shapeRecognitionData.js","mathParameter.js","mathRecognitionInput.js","mathRecognitionData.js","mathStartRequestWSMessage.js","mathContinueRequestWSMessage.js","abstractMusicInputComponent.js","musicAccidentalInputComponent.js","musicArpeggiateInputComponent.js","musicBarInputComponent.js","musicBeamInputComponent.js","musicClefInputComponent.js","musicDecorationInputComponent.js","musicDotsInputComponent.js","musicHeadInputComponent.js","musicLedgerLineInputComponent.js","musicRestInputComponent.js","musicStemInputComponent.js","musicTieOrSlurInputComponent.js","musicTimeSignatureInputComponent.js","musicStaff.js","musicParameter.js","musicRecognitionInput.js","musicRecognitionData.js","analyzerParameter.js","analyzerRecognitionInput.js","analyzerRecognitionData.js","abstractResult.js","abstractRecoResponseWSMessage.js","challengeResponseWSMessage.js","errorResponseWSMessage.js","initResponseWSMessage.js","resetResponseWSMessage.js","textInkRange.js","textCandidate.js","textDocument.js","textResult.js","textSegment.js","textTagItem.js","textResponseWSMessage.js","abstractShapePrimitive.js","shapeCandidate.js","shapeDocument.js","shapeEllipse.js","shapeErased.js","shapeInkRange.js","shapeLine.js","shapeNotRecognized.js","shapeRecognized.js","shapeResult.js","shapeScratchOut.js","shapeSegment.js","mathNode.js","mathNonTerminalNode.js","mathResultElement.js","mathRuleNode.js","mathDocument.js","mathInkRange.js","mathOfficeOpenXmlMathResultElement.js","mathLaTexResultElement.js","mathMathMLResultElement.js","mathResult.js","mathScratchOut.js","mathSymbolTreeResultElement.js","mathTerminalNode.js","mathTerminalNodeCandidate.js","mathBorderData.js","mathBorderNonTerminalNode.js","mathCellData.js","mathCellNonTerminalNode.js","mathTableData.js","mathTableRuleNode.js","mathResponseWSMessage.js","musicElement.js","musicResultElement.js","musicAccidental.js","musicAnnotation.js","musicArpeggiate.js","musicBar.js","musicBeam.js","musicChord.js","musicClef.js","musicDecoration.js","musicDocument.js","musicDots.js","musicHead.js","musicInputRange.js","musicKeySignature.js","musicKeySignatureData.js","musicLedgerLine.js","musicNote.js","musicPart.js","musicPitchData.js","musicRest.js","musicResult.js","musicScore.js","musicScoreTreeResultElement.js","musicScratchOut.js","musicSlur.js","musicStem.js","musicTie.js","musicTimeModificationData.js","musicTimeSignature.js","musicTupletBracket.js","musicTuplet.js","musicXMLResultElement.js","analyzerElement.js","analyzerCell.js","analyzerCellData.js","analyzerDocument.js","analyzerElementReference.js","analyzerGroup.js","analyzerInkRange.js","analyzerLine.js","analyzerLineData.js","analyzerRecognizedStroke.js","analyzerResult.js","analyzerStrokeType.js","analyzerTable.js","analyzerTableData.js","analyzerTextLine.js","analyzerTextLineData.js","analyzerUnderline.js","analyzerUnderlineData.js","networkInterface.js","networkWSInterface.js","abstractRecognizer.js","abstractWSRecognizer.js","textRecognizer.js","textWSRecognizer.js","shapeRecognizer.js","mathRecognizer.js","mathWSRecognizer.js","musicRecognizer.js","analyzerRecognizer.js","abstractRenderer.js","textRenderer.js","shapeRenderer.js","mathRenderer.js","musicRenderer.js","analyzerRenderer.js","imageRenderer.js","inkGrabber.js","inkPaper.js"],"names":["CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","prototype","window","Event","Function","bind","oThis","this","TypeError","aArgs","Array","slice","call","arguments","fToBind","fNOP","fBound","apply","concat","MyScript","RecognitionType","TEXT","MATH","SHAPE","MUSIC","ANALYZER","InputMode","CURSIVE","ISOLATED","SUPERIMPOSED","VERTICAL","InputType","CHAR","WORD","SINGLE_LINE_TEXT","MULTI_LINE_TEXT","ResultDetail","CHARACTER","ResultType","Math","LATEX","MATHML","SYMBOLTREE","OFFICEOPENXMLMATH","Music","MUSICXML","SCORETREE","Protocol","WS","REST","scope","Point","obj","x","y","getX","setX","getY","setY","QuadraticPoint","pressure","distance","length","cos","sin","p1","p2","constructor","getPressure","setPressure","getDistance","setDistance","getLength","setLength","getCos","setCos","getSin","setSin","getP1","setP1","getP2","setP2","Rectangle","width","height","getTopLeftPoint","point","setTopLeftPoint","topLeftPoint","getWidth","setWidth","getHeight","setHeight","InkManager","writing","strokes","currentStroke","undoRedoStack","isWriting","getCurrentStroke","startInkCapture","t","Error","isRedoEmpty","clearUndoRedoStack","Stroke","addX","addY","addT","continueInkCapture","endInkCapture","push","clear","isEmpty","undo","pop","redo","getStrokes","getUndoRedoStack","copy","index","PenParameters","color","rectColor","font","decoration","pressureType","alpha","getColor","setColor","getRectColor","setRectColor","getFont","setFont","getDecoration","setDecoration","getPressureType","setPressureType","getAlpha","setAlpha","RenderingParameters","MathUtils","getEllipseArcRect","center","maxRadius","minRadius","orientation","startAngle","sweepAngle","angle","z1","z2","z3","z4","cosAlpha","sinAlpha","n","xList","yList","i","xMin","xMax","yMin","yMax","angleStep","sortFloat","a","b","abs","atan2","sort","getLineRect","firstPoint","lastPoint","xFirst","xLast","min","max","yFirst","yLast","getBoundingRect","boundingBoxes","rectangle","AbstractWSMessage","type","getType","AbstractComponent","setType","getBoundingBox","setBoundingBox","boundingBox","getT","setT","toFixed","precision","StrokeComponent","p","d","l","toJSON","getP","setP","addP","getD","setD","addD","getL","setL","addL","addPoint","filterPointByAcquisitionDelta","computeP","computeD","computeL","getLastIndexPoint","getPointByIndex","sqrt","pow","isNaN","ratio","parseFloat","delta","ret","CharacterInputComponent","alternates","CharacterInputComponentAlternate","getAlternates","setAlternates","addAlternate","alternate","probability","getAlternate","setAlternate","getProbability","setProbability","AbstractParameter","AbstractRecognitionInput","AbstractRecognitionData","getApplicationKey","applicationKey","setApplicationKey","getInstanceId","instanceId","setInstanceId","getHmac","hmac","setHmac","getRecognitionInput","setRecognitionInput","input","RecognitionLanguagesData","getInputMode","inputMode","setInputMode","AbstractStartRequestWSMessage","AbstractContinueRequestWSMessage","ChallengeRequestWSMessage","getChallenge","challenge","setChallenge","getHmacSignature","setHmacSignature","InitRequestWSMessage","ResetRequestWSMessage","AbstractTextInputComponent","CharInputComponent","character","getCharacter","setCharacter","getLabel","setLabel","label","StringInputComponent","string","getString","setString","TextInputUnit","textInputType","components","getInputType","setInputType","inputType","getComponents","inkRange","TextInkRange","getStartComponent","getEndComponent","setComponents","TextParameter","textProperties","TextProperties","language","textInputMode","contentTypes","subsetKnowledges","userResources","userLkWords","resultDetail","getLanguage","setLanguage","getContentTypes","setContentTypes","getSubsetKnowledges","setSubsetKnowledges","getUserResources","setUserResources","getUserLkWords","setUserLkWords","getResultDetail","setResultDetail","getTextProperties","setTextProperties","textCandidateListSize","wordCandidateListSize","wordPredictionListSize","wordCompletionListSize","characterCandidateListSize","discardCaseVariations","discardAccentuationVariations","disableSpatialOrdering","glyphDistortion","enableOutOfLexicon","spellingDistortion","getTextCandidateListSize","setTextCandidateListSize","getWordCandidateListSize","setWordCandidateListSize","getWordPredictionListSize","setWordPredictionListSize","getWordCompletionListSize","setWordCompletionListSize","getCharacterCandidateListSize","setCharacterCandidateListSize","getDiscardCaseVariations","setDiscardCaseVariations","getDiscardAccentuationVariations","setDiscardAccentuationVariations","getDisableSpatialOrdering","setDisableSpatialOrdering","getGlyphDistortion","setGlyphDistortion","getEnableOutOfLexicon","setEnableOutOfLexicon","getSpellingDistortion","setSpellingDistortion","TextRecognitionInput","getParameters","textParameter","setParameters","parameters","getInputUnits","inputUnits","getStartUnit","getEndUnit","setInputUnits","TextRecognitionData","getTextRecognitionInput","textInput","setTextRecognitionInput","JSON","stringify","TextStartRequestWSMessage","TextContinueRequestWSMessage","ShapeParameter","rejectDetectionSensitivity","doBeautification","getRejectDetectionSensitivity","setRejectDetectionSensitivity","hasBeautification","setBeautification","ShapeRecognitionInput","getDoBeautification","setDoBeautification","ShapeRecognitionData","getShapeRecognitionInput","shapeInput","setShapeRecognitionInput","MathParameter","resultTypes","columnarOperation","scratchOutDetectionSensitivity","getResultTypes","setResultTypes","isColumnar","setColumnar","columnar","getScratchOutDetectionSensitivity","setScratchOutDetectionSensitivity","MathRecognitionInput","MathRecognitionData","getMathRecognitionInput","mathInput","setMathRecognitionInput","MathStartRequestWSMessage","MathContinueRequestWSMessage","AbstractMusicInputComponent","MusicAccidentalInputComponent","value","getValue","setValue","MusicArpeggiateInputComponent","MusicBarInputComponent","MusicBar","MusicBeamInputComponent","MusicBeam","MusicClefInputComponent","MusicClef","MusicDecorationInputComponent","MusicDecoration","MusicDotsInputComponent","MusicHeadInputComponent","MusicLedgerLineInputComponent","MusicRestInputComponent","MusicStemInputComponent","MusicTieOrSlurInputComponent","MusicTimeSignatureInputComponent","MusicStaff","count","gap","top","getCount","setCount","getTop","setTop","getGap","setGap","MusicParameter","divisions","staff","getStaff","setStaff","getDivisions","setDivisions","MusicRecognitionInput","MusicRecognitionData","getMusicRecognitionInput","musicInput","setMusicRecognitionInput","AnalyzerParameter","coordinateResolution","getTextParameters","setTextParameters","getCoordinateResolution","setCoordinateResolution","AnalyzerRecognitionInput","parameter","AnalyzerRecognitionData","getAnalyzerRecognitionInput","analyzerInput","setAnalyzerRecognitionInput","AbstractResult","getDocument","result","AbstractRecoResponseWSMessage","ChallengeResponseWSMessage","ErrorResponseWSMessage","error","getError","InitResponseWSMessage","ResetResponseWSMessage","cpt","split","startUnit","Number","startComponent","startPoint","endUnit","endComponent","endPoint","getStartPoint","getEndPoint","TextCandidate","flags","children","normalizedScore","spellingDistortionRatio","j","TextSegment","getNormalizedScore","getResemblanceScore","resemblanceScore","getSpellingDistortionRatio","getFlags","getChildren","TextDocument","tagItems","wordCandidates","charCandidates","textSegmentResult","TextTagItem","k","getTagItems","getWordSegments","getWordSegment","inkRanges","getInkRanges","getCharSegments","getCharSegment","getTextSegment","hasScratchOutResults","TextResult","getTextDocument","candidates","selectedCandidateIdx","ranges","isArray","getCandidates","getSelectedCandidateIdx","getSelectedCandidate","tagType","getTagType","TextResponseWSMessage","AbstractShapePrimitive","beginDecoration","beginTangentAngle","endDecoration","endTangentAngle","isLine","isEllipse","hasBeginDecoration","hasEndDecoration","getBeginDecoration","getEndDecoration","getBeginTangentAngle","getEndTangentAngle","ShapeCandidate","isErased","isScratchOut","isNotRecognized","isRecognized","ShapeDocument","segments","ShapeSegment","getSegments","currentSeg","currentCandidate","ShapeScratchOut","ShapeEllipse","getCenter","getMinRadius","getMaxRadius","getOrientation","getStartAngle","getSweepAngle","ShapeErased","ShapeInkRange","firstStroke","lastStroke","getFirstStroke","getLastStroke","getFirstPoint","getLastPoint","ShapeLine","ShapeNotRecognized","ShapeRecognized","primitives","normalizedRecognitionScore","getPrimitives","getNormalizedRecognitionScore","ShapeResult","getShapeDocument","elementType","uniqueID","selectedCandidateIndex","getElementType","getUniqueId","MathNode","name","getName","MathNonTerminalNode","selectedCandidate","MathTerminalNode","MathRuleNode","MathCellNonTerminalNode","MathBorderNonTerminalNode","MathTableRuleNode","MathResultElement","isLaTex","isMathMl","isSymbolTree","childInkRanges","MathDocument","results","scratchOutResults","MathMathMLResultElement","MathLaTexResultElement","MathSymbolTreeResultElement","MathOfficeOpenXmlMathResultElement","MathScratchOut","getResultElements","getScratchOutResults","MathInkRange","component","firstItem","lastItem","getComponent","getFirstItem","getLastItem","MathResult","getMathDocument","erasedInkRanges","getErasedInkRanges","root","getRoot","MathTerminalNodeCandidate","MathBorderData","position","start","stop","getPosition","getStart","getStop","data","getData","MathCellData","columnStart","columnStop","rowStart","rowStop","getColumnStart","getColumnStop","getRowStart","getRowStop","MathTableData","columnCount","rowCount","getColumnCount","getRowCount","MathResponseWSMessage","MusicElement","inputRanges","getInputRanges","MusicResultElement","isMusicXML","isScoreTree","MusicAccidental","MusicAnnotation","MusicArpeggiate","decorations","repeatDirection","style","getRepeatDirection","setRepeatDirection","getStyle","setStyle","getDecorations","setDecorations","slope","placement","leftCount","rightCount","getSlope","setSlope","getPlacement","setPlacement","getLeftCount","setLeftCount","getRightCount","setRightCount","MusicChord","notes","beamTypes","ledgerLines","startSlurs","stopSlurs","duration","arpeggiate","startBeam","stopBeam","stem","MusicStem","MusicNote","MusicLedgerLine","m","MusicSlur","getDuration","getArpeggiate","getStartBeam","getStopBeam","getStem","getNotes","getBeamTypes","getLedgerLines","getStartSlurs","getStopSlurs","symbol","octave","line","yAnchor","getYAnchor","setYAnchor","getLine","setLine","getOctave","setOctave","getSymbol","setSymbol","MusicDocument","MusicXMLResultElement","MusicScoreTreeResultElement","MusicScratchOut","MusicDots","MusicHead","MusicInputRange","MusicKeySignature","accidentals","signature","MusicKeySignatureData","getSignature","getAccidentals","fifths","cancel","getFifths","getCancel","accidental","dots","head","pitch","MusicPitchData","startTie","MusicTie","stopTie","startTuplet","MusicTuplet","stopTuplet","timeModification","MusicTimeModificationData","getAccidental","getDots","getHead","getPitch","getStartTie","getStopTie","getStartTuplet","getStopTuplet","getTimeModification","MusicPart","elements","MusicRest","MusicTimeSignature","MusicTupletBracket","getElements","alteration","step","getAlteration","getStep","MusicResult","getMusicDocument","MusicScore","parts","getParts","score","getScore","erasedInputRanges","getErasedInputRanges","actual","normal","getActual","getNormal","bottom","getBottom","brackets","number","getNumber","getBrackets","AnalyzerElement","AnalyzerCell","AnalyzerCellData","firstColumn","lastColumn","firstRow","lastRow","topBorder","bottomBorder","leftBorder","rightBorder","getFirstColumn","getLastColumn","getFirstRow","getLastRow","hasTopBorder","hasBottomBorder","hasLeftBorder","hasRightBorder","AnalyzerDocument","textLines","shapes","tables","groups","AnalyzerTextLine","AnalyzerTable","AnalyzerGroup","getTextLines","getShapes","getTables","getGroups","AnalyzerElementReference","elementReferences","getElementReferences","AnalyzerInkRange","stroke","AnalyzerRecognizedStroke","getStroke","AnalyzerLine","AnalyzerLineData","AnalyzerResult","getAnalyzerDocument","AnalyzerStrokeType","getInkRange","lines","cells","AnalyzerTableData","getLines","getCells","underlineList","AnalyzerTextLineData","AnalyzerUnderline","getUnderlineList","baselinePos","toMidline","textHeight","justificationType","getBaselinePos","getToMidline","getTextHeight","getJustificationType","AnalyzerUnderlineData","firstCharacter","lastCharacter","getFirstCharacter","getLastCharacter","Q","NetworkInterface","parseURL","url","queries","parser","createElement","searchObject","href","search","replace","protocol","host","hostname","port","pathname","hash","parse","req","responseText","e","transformRequest","str","encodeURIComponent","join","xhr","Promise","resolve","reject","notify","onStateChange","request","readyState","status","onLoad","onError","onProgress","loaded","total","XMLHttpRequest","open","withCredentials","setRequestHeader","onerror","onprogress","onload","onreadystatechange","send","get","src","put","post","NetworkWSInterface","setUrl","close","_url","getUrl","setCallback","callback","_callback","getCallback","getState","_getWebSocketState","_socket","isClosed","isClosing","isOpen","isConnecting","_openWebSocket","code","reason","_closeWebSocket","state","_sendMessage","onOpen","onClose","onMessage","socket","WebSocket","onopen","onclose","onmessage","message","CryptoJS","AbstractRecognizer","getProtocol","setSSL","_ssl","getSSL","ssl","getHost","setHost","getPrecision","setPrecision","getAvailableLanguageList","then","response","doRestRecognition","hmacKey","_filterStrokes","_doTextRecognition","_doShapeRecognition","_doMathRecognition","_doMusicRecognition","_doAnalyzerRecognition","clearRestRecognition","instanceSessionId","_clearShapeRecognition","_fillData","computeHmac","_computeHmac","jsonInput","HmacSHA512","toString","enc","Hex","forEach","currentValue","AbstractWSRecognizer","_wsInterface","sendMessage","initWSRecognition","takeUpHmacChallenge","resetWSRecognition","TextRecognizer","doSimpleRecognition","TextWSRecognizer","startWSRecognition","continueWSRecognition","ShapeRecognizer","clearShapeRecognitionSession","MathRecognizer","MathWSRecognizer","MusicRecognizer","AnalyzerRecognizer","AbstractRenderer","context","penParameters","showBoundingBoxes","typeset","points","drawing","_computeLinksPoints","radius","_computeMiddlePoint","point1","point2","_computeAxeAngle","begin","end","_fill","fillStyle","fill","_renderStroke","beginPath","arc","PI","_renderLine","nbquadratics","_renderQuadratic","_renderFinal","closePath","ARCSPLIT","linkPoints","moveTo","newAngle","lineTo","linkPoints1","linkPoints2","ctrl","linkPoints3","quadraticCurveTo","getContext","_setContext","getShowBoundingBoxes","setShowBoundingBoxes","isTypesetting","setTypeset","clearRect","canvas","drawRecognitionResult","recognitionResult","drawComponents","drawComponent","drawStroke","drawCharacter","drawRectangle","save","strokeStyle","lineWidth","fillRect","restore","drawStart","drawContinue","drawEnd","drawStrokes","last","pA","pB","pAB","_computePointParameters","_computeFirstControls","_computeControls","_drawFirstSegment","pC","pBC","_drawSegment","_drawPoint","_computeLastControls","_drawLastSegment","globalAlpha","previous","dx","dy","_computePressure","first","next","penWidth","r","nx","ny","u","TextRenderer","drawInputUnits","_drawTextComponent","drawTextComponent","_drawChar","_drawString","char","ShapeRenderer","drawShapes","_drawShapePrimitive","drawShapeSegment","segment","candidate","_drawShapeRecognized","drawShapeNotRecognized","drawShapeRecognized","shapeRecognized","notRecognized","_extractShapeNotRecognized","drawShapePrimitive","primitive","drawShapeLine","shapeLine","_drawShapeLine","drawShapeEllipse","shapeEllipse","_drawShapeEllipse","_drawLine","_drawArrowHead","_drawEllipseArc","extractStroke","centerPoint","floor","boundariesPoints","_phi","headPoint","beta","firstPointIndex","lastPointIndex","ceil","strokeIndex","currentStrokePointCount","newStroke","pointIndex","MathRenderer","notScratchOutComponents","_removeMathScratchOut","removeScratchOut","cloneComponents","componentsToRemove","z","splice","MusicRenderer","_removeMusicScratchOut","drawStaff","_drawStaff","_drawMusicNode","drawMusicNode","staffHeight","staves","offset","clientWidth","_drawAccidental","_drawArpeggiate","_drawBar","_drawBeam","_drawClef","_drawDecoration","_drawDots","_drawHead","_drawLedgerLine","_drawRest","_drawStem","_drawTieOrSlur","_drawTimeSignature","bar","beam","clef","imageObj","Image","drawImage","ledgerLine","rest","tieOrSlur","timeSignature","AnalyzerRenderer","shapeRenderer","getShapeRenderer","setShapeRenderer","_drawTables","_drawTextLines","drawTables","_drawCell","drawTextLines","textLine","drawText","text","baseline","_drawText","drawUnderline","underline","_drawUnderline","drawGroups","_drawGroups","drawCell","cell","underlines","textAlign","fillText","topLeft","textMetrics","measureText","substring","x1","x2","ImageRenderer","console","log","InkGrabber","startCapture","continueCapture","endCapture","InkPaper","element","options","_element","_instanceId","_timerId","_initialized","redoComponents","lastNonRecoComponentIdx","resultCallback","changeCallback","canvasRatio","_captureCanvas","_createCanvas","_inkGrabber","_renderingCanvas","_getCanvasRatio","_textRenderer","_mathRenderer","_shapeRenderer","_musicRenderer","_analyzerRenderer","_textRecognizer","_mathRecognizer","_shapeRecognizer","_musicRecognizer","_analyzerRecognizer","_textWSRecognizer","_handleMessage","_mathWSRecognizer","_attachListeners","timeout","textParameters","mathParameters","shapeParameters","musicParameters","analyzerParameters","idx","setMathParameters","setShapeParameters","setMusicParameters","setAnalyzerParameters","setProtocol","setTimeout","setHmacKey","setPenParameters","parent","id","querySelectorAll","appendChild","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","_getCoordinates","container","changedTouches","rect","getBoundingClientRect","clientX","left","clientLeft","clientY","clientTop","timeStamp","scale","_initRenderingCanvas","_selectedRecognizer","_selectedRESTRecognizer","_selectedWSRecognizer","_selectedRenderer","getTimeout","getHmacKey","isStarted","map","toUpperCase","getMathParameters","getShapeParameters","getMusicParameters","getAnalyzerParameters","getPenParameters","getAvailableLanguages","_onResult","getRenderer","getInkGrabber","getRecognizer","setChangeCallback","setResultCallback","recognize","_doRecognition","canUndo","_onChange","clearTimeout","canRedo","addDomListener","useCapture","myfunction","addEventListener","_down","sizeChanged","clientHeight","_move","_up","inputWS","inputUnitWS","inputUnit","_parseResult","err","dispatchEvent","undoLength","redoLength","pointerId","self","preventDefault","stopPropagation","coord","_drawInput","replayNeeded","getStats","stats","strokesCount","pointsCount","byteSize","humanSize","humanUnit","strokeNb","getInkAsImageData","marginX","marginY","minX","maxX","minY","maxY","pointCount","pointNb","currentX","currentY","nonDisplayCanvas","ctx","imageRendered","imageData","getImageData","getInkAsPng","imageRenderingCanvas","display","imageDataToRender","putImageData","toDataURL"],"mappings":"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","file":"myscript.min.js","sourcesContent":["/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE',\n            OFFICEOPENXMLMATH : 'OFFICEOPENXMLMATH'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n\n\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Complex Point object used for quadratic calculation\n     *\n     * @deprecated\n     * @class QuadraticPoint\n     * @extends Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function QuadraticPoint(obj) {\n        scope.Point.call(this, obj);\n        this.pressure = 0.5;\n        this.distance = 0.0;\n        this.length = 0.0;\n        this.cos = 0.0;\n        this.sin = 0.0;\n        this.p1 = new scope.Point(obj);\n        this.p2 = new scope.Point(obj);\n        if (obj) {\n            this.pressure = obj.pressure;\n            this.distance = obj.distance;\n            this.length = obj.length;\n            this.cos = obj.cos;\n            this.sin = obj.sin;\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    QuadraticPoint.prototype = new scope.Point();\n\n    /**\n     * Constructor property\n     */\n    QuadraticPoint.prototype.constructor = QuadraticPoint;\n\n    /**\n     * Get pressure\n     *\n     * @method getPressure\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getPressure = function () {\n        return this.pressure;\n    };\n\n    /**\n     * Set pressure\n     *\n     * @method setPressure\n     * @param {Number} pressure\n     */\n    QuadraticPoint.prototype.setPressure = function (pressure) {\n        this.pressure = pressure;\n    };\n\n    /**\n     * Get distance\n     *\n     * @method getDistance\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getDistance = function () {\n        return this.distance;\n    };\n\n    /**\n     * Set distance\n     *\n     * @method setDistance\n     * @param {Number} distance\n     */\n    QuadraticPoint.prototype.setDistance = function (distance) {\n        this.distance = distance;\n    };\n\n    /**\n     * Get length\n     *\n     * @method getLength\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getLength = function () {\n        return this.length;\n    };\n\n    /**\n     * Set length\n     *\n     * @method setLength\n     * @param {Number} length\n     */\n    QuadraticPoint.prototype.setLength = function (length) {\n        this.length = length;\n    };\n\n    /**\n     * Get cos\n     *\n     * @method getCos\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getCos = function () {\n        return this.cos;\n    };\n\n    /**\n     * Set cos\n     *\n     * @method setCos\n     * @param {Number} cos\n     */\n    QuadraticPoint.prototype.setCos = function (cos) {\n        this.cos = cos;\n    };\n\n    /**\n     * Get sin\n     *\n     * @method getSin\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getSin = function () {\n        return this.sin;\n    };\n\n    /**\n     * Set sin\n     *\n     * @method setSin\n     * @param {Number} sin\n     */\n    QuadraticPoint.prototype.setSin = function (sin) {\n        this.sin = sin;\n    };\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Set p1\n     *\n     * @method setP1\n     * @param {Point} p1\n     */\n    QuadraticPoint.prototype.setP1 = function (p1) {\n        this.p1 = p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    /**\n     * Set p2\n     *\n     * @method setP2\n     * @param {Point} p2\n     */\n    QuadraticPoint.prototype.setP2 = function (p2) {\n        this.p2 = p2;\n    };\n\n    // Export\n    scope.QuadraticPoint = QuadraticPoint;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * The InkManager class that can use to store writing strokes and manage the undo/redo/clear system\n     *\n     * @deprecated\n     * @class InkManager\n     * @constructor\n     */\n    function InkManager() {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    }\n\n    /**\n     * Is Writing a stroke\n     *\n     * @deprecated\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last current Stroke write\n     *\n     * @deprecated\n     * @method getCurrentStroke\n     * @returns {Stroke}\n     */\n    InkManager.prototype.getCurrentStroke = function () {\n        return this.currentStroke;\n    };\n\n    /**\n     * Start ink capture\n     *\n     * @deprecated\n     * @method startInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.startInkCapture = function (x, y, t) {\n        if (!this.writing) {\n            if (!this.isRedoEmpty()) {\n                this.clearUndoRedoStack();\n            }\n            this.currentStroke = new scope.Stroke();\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n            this.writing = true;\n        } else {\n            throw new Error('Stroke capture already running');\n        }\n    };\n\n    /**\n     * Continue ink capture\n     *\n     * @deprecated\n     * @method continueInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.continueInkCapture = function (x, y, t) {\n        if (this.writing) {\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * End ink capture\n     *\n     * @deprecated\n     * @method endInkCapture\n     */\n    InkManager.prototype.endInkCapture = function () {\n        if (this.writing) {\n            this.strokes.push(this.currentStroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * Clear the strokes list\n     *\n     * @deprecated\n     * @method clear\n     */\n    InkManager.prototype.clear = function () {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Is The Strokes list is empty\n     *\n     * @deprecated\n     * @method isEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isEmpty = function () {\n        return this.strokes.length === 0;\n    };\n\n    /**\n     * Is the Undo/Redo Stack empty\n     *\n     * @method isRedoEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isRedoEmpty = function () {\n        return this.undoRedoStack.length === 0;\n    };\n\n    /**\n     * Make an undo\n     *\n     * @deprecated\n     * @method undo\n     */\n    InkManager.prototype.undo = function () {\n        if (!this.isEmpty()) {\n            this.undoRedoStack.push(this.strokes.pop());\n        }\n    };\n\n    /**\n     * Make a redo\n     *\n     * @deprecated\n     * @method redo\n     */\n    InkManager.prototype.redo = function () {\n        if (!this.isRedoEmpty()) {\n            this.strokes.push(this.undoRedoStack.pop());\n        }\n    };\n\n    /**\n     * Get the strokes list\n     *\n     * @deprecated\n     * @method getStokes\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getStrokes = function () {\n        return this.strokes;\n    };\n\n    /**\n     * Get the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method getUndoRedoStack\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getUndoRedoStack = function () {\n        return this.undoRedoStack;\n    };\n\n    /**\n     * Clear the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method clearUndoRedoStack\n     */\n    InkManager.prototype.clearUndoRedoStack = function () {\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Copy the strokes values from index on an other list of strokes\n     *\n     * @deprecated\n     * @method copy\n     * @param {Stroke[]} strokes List of strokes\n     * @param {Number} index Position to start the copy\n     */\n    InkManager.prototype.copy = function (strokes, index) {\n        for (index; index < this.strokes.length; index++) {\n            strokes.push(this.strokes[index]);\n        }\n    };\n\n    // Export\n    scope.InkManager = InkManager;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get the pressure renderer parameter\n     *\n     * @deprecated\n     * @method getPressureType\n     * @returns {String} The pressure type\n     */\n    PenParameters.prototype.getPressureType = function () {\n        return this.pressureType;\n    };\n\n    /**\n     * Set the pressure renderer parameter\n     *\n     * @deprecated\n     * @method setPressureType\n     * @param {String} pressureType\n     */\n    PenParameters.prototype.setPressureType = function (pressureType) {\n        this.pressureType = pressureType;\n    };\n\n    /**\n     * Get the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method getAlpha\n     * @returns {String} The alpha\n     */\n    PenParameters.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * Set the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method setAlpha\n     * @param {String} alpha\n     */\n    PenParameters.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @deprecated Use 'PenParameters' instead\n     * @class RenderingParameters\n     * @constructor\n     */\n    function RenderingParameters() {\n        scope.PenParameters.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    RenderingParameters.prototype = new scope.PenParameters();\n\n    /**\n     * Constructor property\n     */\n    RenderingParameters.prototype.constructor = RenderingParameters;\n\n    // Export\n    scope.RenderingParameters = RenderingParameters;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @deprecated Use StrokeComponent instead\n     * @class Stroke\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function Stroke(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        if (obj) {\n            if (obj.x) {\n                this.x = obj.x;\n            }\n            if (obj.y) {\n                this.y = obj.y;\n            }\n            if (obj.t) {\n                this.t = obj.t;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    Stroke.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    Stroke.prototype.constructor = Stroke;\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    Stroke.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    Stroke.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    Stroke.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    Stroke.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    Stroke.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    Stroke.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    Stroke.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    Stroke.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    Stroke.prototype.toFixed = function (precision) {\n        if (precision !== undefined) {\n            for (var i in this.x) {\n                this.x[i] = this.x[i].toFixed(precision);\n                this.y[i] = this.y[i].toFixed(precision);\n            }\n        }\n    };\n\n    // Export\n    scope.Stroke = Stroke;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @class StrokeComponent\n     * @extends Stroke\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.Stroke.call(this);\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            if (obj.p) {\n                this.p = obj.p;\n            }\n            if (obj.d) {\n                this.d = obj.d;\n            }\n            if (obj.l) {\n                this.l = obj.l;\n            }\n            if (obj.color) {\n                this.color = obj.color;\n            }\n            if (obj.alpha) {\n                this.alpha = obj.alpha;\n            }\n            if (obj.width) {\n                this.width = obj.width;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.Stroke();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**     *\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (this.filterPointByAcquisitionDelta(x, y)) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(this.computeP(x, y));\n            this.addD(this.computeD(x, y));\n            this.addL(this.computeL(x, y));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    StrokeComponent.prototype.computeD = function (x, y) {\n        var distance = Math.sqrt(Math.pow((y - this.getY()[this.getLastIndexPoint() - 1]), 2) + Math.pow((x - this.getX()[this.getLastIndexPoint() - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    };\n\n    StrokeComponent.prototype.computeL = function (x, y) {\n        var length = this.getL()[this.getLastIndexPoint() - 1] + this.computeD(x, y);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    };\n\n    StrokeComponent.prototype.computeP = function (x, y) {\n        var ratio = 1.0;\n        var distance = this.computeD(x, y);\n        var length = this.computeL(x, y);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    };\n\n    StrokeComponent.prototype.filterPointByAcquisitionDelta = function (x, y) {\n        var delta = (2 + (this.getWidth() / 4));\n        var ret = false;\n        if (this.getLength() === 0 || Math.abs(this.getX()[this.getLastIndexPoint()] - x) >= delta || Math.abs(this.getY()[this.getLastIndexPoint()] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    };\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n        if (obj) {\n            if (obj.alternates) {\n                for (var i in obj.alternates) {\n                    this.alternates.push(new scope.CharacterInputComponentAlternate(obj.alternates[i]));\n                }\n            }\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(obj) {\n        if (obj) {\n            if (obj.alternate) {\n                this.alternate = obj.alternate;\n            }\n            if (obj.probability) {\n                this.probability = obj.probability;\n            }\n        }\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'char';\n        if (obj) {\n            if (obj.character) {\n                this.character = obj.character;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get character\n     *\n     * @deprecated Use 'getLabel'\n     * @method getCharacter\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getCharacter = function () {\n        return this.character;\n    };\n\n    /**\n     * Set character\n     *\n     * @deprecated Use 'setLabel'\n     * @method setCharacter\n     * @param {String} character\n     */\n    CharInputComponent.prototype.setCharacter = function (character) {\n        this.character = character;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'string';\n        if (obj) {\n            if (obj.string) {\n                this.string = obj.string;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get string\n     *\n     * @deprecated Use 'getLabel'\n     * @method getString\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getString = function () {\n        return this.string;\n    };\n\n    /**\n     * Set string\n     *\n     * @deprecated Use 'setLabel'\n     * @method setString\n     * @param {String} string\n     */\n    StringInputComponent.prototype.setString = function (string) {\n        this.string = string;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n        if (obj) {\n            if (obj.language) {\n                this.language = obj.language;\n            }\n            if (obj.textInputMode) {\n                this.textInputMode = obj.textInputMode;\n            }\n            if (obj.contentTypes) {\n                this.contentTypes = obj.contentTypes;\n            }\n            if (obj.subsetKnowledges) {\n                this.subsetKnowledges = obj.subsetKnowledges;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.userLkWords) {\n                this.userLkWords = obj.userLkWords;\n            }\n            if (obj.resultDetail) {\n                this.resultDetail = obj.resultDetail;\n            }\n            if (obj.textProperties) {\n                this.textProperties = new scope.TextProperties(obj.textProperties);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties(obj) {\n        if (obj) {\n            if (obj.textCandidateListSize) {\n                this.textCandidateListSize = obj.textCandidateListSize;\n            }\n            if (obj.wordCandidateListSize) {\n                this.wordCandidateListSize = obj.wordCandidateListSize;\n            }\n            if (obj.wordPredictionListSize) {\n                this.wordPredictionListSize = obj.wordPredictionListSize;\n            }\n            if (obj.wordCompletionListSize) {\n                this.wordCompletionListSize = obj.wordCompletionListSize;\n            }\n            if (obj.characterCandidateListSize) {\n                this.characterCandidateListSize = obj.characterCandidateListSize;\n            }\n            if (obj.discardCaseVariations) {\n                this.discardCaseVariations = obj.discardCaseVariations;\n            }\n            if (obj.discardAccentuationVariations) {\n                this.discardAccentuationVariations = obj.discardAccentuationVariations;\n            }\n            if (obj.disableSpatialOrdering) {\n                this.disableSpatialOrdering = obj.disableSpatialOrdering;\n            }\n            if (obj.glyphDistortion) {\n                this.glyphDistortion = obj.glyphDistortion;\n            }\n            if (obj.enableOutOfLexicon) {\n                this.enableOutOfLexicon = obj.enableOutOfLexicon;\n            }\n            if (obj.spellingDistortion) {\n                this.spellingDistortion = obj.spellingDistortion;\n            }\n        }\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getTextRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getTextRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setTextRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setTextRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        if (obj) {\n            if (obj.rejectDetectionSensitivity) {\n                this.rejectDetectionSensitivity = obj.rejectDetectionSensitivity;\n            }\n            if (obj.doBeautification) {\n                this.doBeautification = obj.doBeautification;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {ShapeParameter}\n     */\n    ShapeRecognitionInput.prototype.getParameters = function () {\n        return new ShapeParameter({\n            rejectDetectionSensitivity: this.rejectDetectionSensitivity,\n            doBeautification: this.doBeautification,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {ShapeParameter} parameters\n     */\n    ShapeRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.rejectDetectionSensitivity = parameters.getRejectDetectionSensitivity();\n            this.doBeautification = parameters.hasBeautification();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @deprecated Use getParameters instead of getDoBeautification\n     * @method getDoBeautification\n     * @returns {Boolean}\n     */\n    ShapeRecognitionInput.prototype.getDoBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @deprecated Use setParameters instead of setDoBeautification\n     * @method setDoBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeRecognitionInput.prototype.setDoBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @deprecated Use getParameters instead of getRejectDetectionSensitivity\n     * @method getRejectDetectionSensitivity\n     * @returns {Number}\n     */\n    ShapeRecognitionInput.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @deprecated Use setParameters instead of setRejectDetectionSensitivity\n     * @method setRejectDetectionSensitivity\n     * @param {Number} rejectDetectionSensitivity\n     */\n    ShapeRecognitionInput.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getShapeRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getShapeRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setShapeRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setShapeRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n            if (obj.columnarOperation) {\n                this.columnarOperation = obj.columnarOperation;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathRecognitionInput.prototype.getParameters = function () {\n        return new MathParameter({\n            resultTypes: this.resultTypes,\n            columnarOperation: this.columnarOperation,\n            userResources: this.userResources,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.resultTypes = parameters.getResultTypes();\n            this.columnarOperation = parameters.isColumnar();\n            this.userResources = parameters.getUserResources();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @deprecated Use getParameters instead of getResultTypes\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @deprecated Use setParameters instead of setResultTypes\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @deprecated Use getParameters instead of isColumnar\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathRecognitionInput.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @deprecated Use setParameters instead of setColumnar\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathRecognitionInput.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @deprecated Use getParameters instead of getUserResources\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @deprecated Use setParameters instead of setUserResources\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use getParameters instead of getScratchOutDetectionSensitivity\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use setParameters instead of setScratchOutDetectionSensitivity\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n    /**\n     * Get math input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMathRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getMathRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMathRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setMathRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'accidental';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'arpeggiate';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBar(obj.value);\n            }\n        }\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBeam(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicClef(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicDecoration(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'dots';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'head';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'rest';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'stem';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'tieOrSlur';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'timeSignature';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff(obj) {\n        this.count = 5;\n        this.gap = 20;\n        if (obj) {\n            if (obj.count) {\n                this.count = obj.count;\n            }\n            if (obj.gap) {\n                this.gap = obj.gap;\n            }\n            if (obj.top) {\n                this.top = obj.top;\n            }\n        }\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.divisions) {\n                this.divisions = obj.divisions;\n            }\n            if (obj.staff) {\n                this.staff = new scope.MusicStaff(obj.staff);\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MusicParameter}\n     */\n    MusicRecognitionInput.prototype.getParameters = function () {\n        return new MusicParameter({\n            divisions: this.divisions,\n            staff: this.staff,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity,\n            resultTypes: this.resultTypes,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MusicParameter} parameters\n     */\n    MusicRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.divisions = parameters.getDivisions();\n            this.staff = parameters.getStaff();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n            this.resultTypes = parameters.getResultTypes();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the result types\n     *\n     * @deprecated Use getParameters instead of getResultTypes\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the result types\n     *\n     * @deprecated Use setParameters instead of setResultTypes\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @deprecated Use getParameters instead of getUserResources\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @deprecated Use setParameters instead of setUserResources\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use getParameters instead of getScratchOutDetectionSensitivity\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use setParameters instead of setScratchOutDetectionSensitivity\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @deprecated Use getParameters instead of getStaff\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicRecognitionInput.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @deprecated Use setParameters instead of setStaff\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRecognitionInput.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @deprecated Use getParameters instead of getDivisions\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @deprecated Use setParameters instead of setDivisions\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicRecognitionInput.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMusicRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getMusicRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMusicRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setMusicRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n        if (obj) {\n            if (obj.coordinateResolution) {\n                this.coordinateResolution = obj.coordinateResolution;\n            }\n            if (obj.textParameter) {\n                this.textParameter = new scope.TextParameter(obj.textParameter);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getAnalyzerRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getAnalyzerRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setAnalyzerRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setAnalyzerRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            if (typeof obj === 'string') {\n                var cpt = obj.split(/[:-]+/);\n                this.startUnit = Number(cpt[0]);\n                this.startComponent = Number(cpt[1]);\n                this.startPoint = Number(cpt[2]);\n                this.endUnit = Number(cpt[3]);\n                this.endComponent = Number(cpt[4]);\n                this.endPoint = Number(cpt[5]);\n            } else {\n                this.startUnit = obj.startUnit;\n                this.startComponent = obj.startComponent;\n                this.startPoint = obj.startPoint;\n                this.endUnit = obj.endUnit;\n                this.endComponent = obj.endComponent;\n                this.endPoint = obj.endPoint;\n            }\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordCandidates = [];\n        this.charCandidates = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordCandidates) {\n                this.wordCandidates.push(new scope.TextSegment(obj.wordCandidates[j]));\n            }\n            for (var k in obj.charCandidates) {\n                this.charCandidates.push(new scope.TextSegment(obj.charCandidates[k]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordCandidates;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charCandidates;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResult.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResponseWSMessage.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    /**\n     * Get shape document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getShapeDocument\n     * @returns {ShapeDocument}\n     */\n    ShapeResult.prototype.getShapeDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);\n(function (scope) {\n    \n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    case 'OFFICEOPENXMLMATH':\n                        this.results.push(new scope.MathOfficeOpenXmlMathResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MathOfficeOpenXmlMathResultElement result element\n     *\n     * @class MathOfficeOpenXmlMathResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathOfficeOpenXmlMathResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n\n    /**\n     * Inheritance property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.constructor = MathOfficeOpenXmlMathResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathOfficeOpenXmlMathResultElement = MathOfficeOpenXmlMathResultElement;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResult.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResponseWSMessage.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    /**\n     * Get music document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMusicDocument\n     * @returns {MusicDocument}\n     */\n    MusicResult.prototype.getMusicDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    /**\n     * Get analyzer document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getAnalyzerDocument\n     * @returns {AnalyzerDocument}\n     */\n    AnalyzerResult.prototype.getAnalyzerDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);\n\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    NetworkInterface.parseURL = function (url) {\n\n        var parser = document.createElement('a'),\n            searchObject = {},\n            queries, split, i;\n        // Let the browser do the work\n        parser.href = url;\n        // Convert query string to object\n        queries = parser.search.replace(/^\\?/, '').split('&');\n        for (i = 0; i < queries.length; i++) {\n            split = queries[i].split('=');\n            searchObject[split[0]] = split[1];\n        }\n        return {\n            protocol: parser.protocol,\n            host: parser.host,\n            hostname: parser.hostname,\n            port: parser.port,\n            pathname: parser.pathname,\n            search: parser.search,\n            searchObject: searchObject,\n            hash: parser.hash\n        };\n    };\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        return Q.Promise(function (resolve, reject, notify) {\n\n            function onStateChange() {\n                if (request.readyState === 4) {\n                    if (request.status >= 200 && request.status < 300) {\n                        resolve(NetworkInterface.parse(request));\n                    }\n                }\n            }\n\n            function onLoad() {\n                if (request.status >= 200 && request.status < 300) {\n                    resolve(NetworkInterface.parse(request));\n                } else {\n                    reject(new Error(request.responseText));\n                }\n            }\n\n            function onError() {\n                reject(new Error('Can\\'t XHR ' + url));\n            }\n\n            function onProgress(e) {\n                notify(e.loaded / e.total);\n            }\n\n            var request = new XMLHttpRequest();\n            request.open(type, url, true);\n            request.withCredentials = true;\n            request.setRequestHeader('Accept', 'application/json');\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            request.onerror = onError;\n            request.onprogress = onProgress;\n            request.onload = onLoad;\n            request.onreadystatechange = onStateChange;\n            request.send(NetworkInterface.transformRequest(data));\n        });\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n\n\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface() {\n    }\n\n    NetworkWSInterface.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.close();\n            this._url = url;\n        }\n    };\n\n    NetworkWSInterface.prototype.getUrl = function () {\n        return this._url;\n    };\n\n    NetworkWSInterface.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this.close();\n            this._callback = callback;\n        }\n    };\n\n    NetworkWSInterface.prototype.getCallback = function () {\n        return this._callback;\n    };\n\n    NetworkWSInterface.prototype.getState = function () {\n        return _getWebSocketState(this._socket);\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        return this.getState() === 3;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        return this.getState() === 2;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        return this.getState() === 1;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        return this.getState() === 0;\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        if (this.getUrl() && this.getCallback() && ((this.getState() < 0) || this.isClosed())) {\n            this._socket = _openWebSocket(this.getUrl(), this.getCallback());\n        }\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this.getState() < 2) {\n            _closeWebSocket(this._socket, code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.send = function (request) {\n        var state = _getWebSocketState(this._socket);\n        if (state  === 1) {\n            _sendMessage(this._socket, request);\n        }\n    };\n\n    /**\n     *\n     * @param url\n     * @param callback\n     * @returns {WebSocket}\n     * @private\n     */\n    var _openWebSocket = function (url, callback) {\n        function onOpen(e) {\n            callback(e);\n        }\n        function onClose(e) {\n            callback(e);\n        }\n        function onError(e) {\n            callback(e);\n        }\n        function onMessage(e) {\n            callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        }\n\n        var socket = new WebSocket(url);\n        socket.onopen = onOpen;\n        socket.onclose = onClose;\n        socket.onerror = onError;\n        socket.onmessage = onMessage;\n        return socket;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param code\n     * @param reason\n     * @private\n     */\n    var _closeWebSocket = function (socket, code, reason) {\n        if (socket) {\n            socket.close(code, reason);\n        }\n    };\n\n    /**\n     *\n     * @param socket\n     * @returns {*}\n     * @private\n     */\n    var _getWebSocketState = function (socket) {\n        if (socket) {\n            return socket.readyState;\n        }\n        return -1;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param message\n     * @private\n     */\n    var _sendMessage = function (socket, message) {\n        if (socket) {\n            socket.send(JSON.stringify(message));\n        }\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n\n\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n    }\n\n    AbstractRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'https://': 'http://';\n    };\n\n    AbstractRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getUrl\n     * @returns {String}\n     */\n    AbstractRecognizer.prototype.getUrl = function() {\n        return this.url;\n    };\n\n    /**\n     * Set the recognition service url\n     *\n     * @method setUrl\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.url = url;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get(this.getUrl() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @private\n     * @method doRestRecognition\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (input, applicationKey, hmacKey, instanceId) {\n        if (input.getComponents) {\n            _filterStrokes(input.getComponents(), this.getPrecision());\n        } else if (input.getInputUnits) {\n            for (var i in input.getInputUnits()) {\n                _filterStrokes(input.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n\n        if (input instanceof scope.TextRecognitionInput) {\n            return _doTextRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.ShapeRecognitionInput) {\n            return _doShapeRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MathRecognitionInput) {\n            return _doMathRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MusicRecognitionInput) {\n            return _doMusicRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.AnalyzerRecognitionInput) {\n            return _doAnalyzerRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getUrl(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} url\n     * @param {TextRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.TextRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} url\n     * @param {ShapeRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.ShapeRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} url\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (url, instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} url\n     * @param {MathRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MathRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} url\n     * @param {MusicRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MusicRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} url\n     * @param {AnalyzerRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.AnalyzerRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @deprecated\n     * @method computeHmac\n     * @param {String} applicationKey\n     * @param {String} data\n     * @param {String} hmacKey\n     */\n    AbstractRecognizer.prototype.computeHmac = function (applicationKey, data, hmacKey) {\n        return _computeHmac(data, applicationKey, hmacKey);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.Stroke) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    var _fillData = function (data, input, instanceId, applicationKey, hmacKey) {\n        data.setRecognitionInput(input);\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n\n\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @constructor\n     */\n    function AbstractWSRecognizer() {\n        this._wsInterface = new scope.NetworkWSInterface();\n    }\n\n    AbstractWSRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'wss://': 'ws://';\n    };\n\n    AbstractWSRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractWSRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractWSRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractWSRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    AbstractWSRecognizer.prototype.setUrl = function (url) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    AbstractWSRecognizer.prototype.getUrl = function () {\n        return this._wsInterface.getUrl();\n    };\n\n    AbstractWSRecognizer.prototype.setCallback = function (callback) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractWSRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractWSRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        if (message.getComponents) {\n            _filterStrokes(message.getComponents(), this.getPrecision());\n        } else if (message.getInputUnits) {\n            for (var i in message.getInputUnits()) {\n                _filterStrokes(message.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(_computeHmac(challenge, applicationKey, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {String} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.Stroke) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript, CryptoJS);\n\n\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, inputUnits, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.TextRecognitionInput();\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    TextWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/text');\n        }\n    };\n\n    TextWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.TextResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (inputUnits, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (inputUnits, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.ShapeRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MathRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.MathParameter();\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    MathWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/math');\n        }\n    };\n\n    MathWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.MathResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MusicRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n        this.points = [];\n        this.drawing = false;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * Set the context (legacy code for non-regression)\n     *\n     * @private\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype._setContext = function (context) {\n        this.context = context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponents = function (components, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponent = function (component, context, parameters) {\n        if (component instanceof scope.Stroke) {\n            this.drawStroke(component, context, parameters);\n        } else if (component instanceof scope.CharacterInputComponent) {\n            this.drawCharacter(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @method drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRectangle = function (rectangle, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n\n        var params = this.getParameters();\n        this.getContext().save();\n        try {\n            this.getContext().fillStyle = params.getRectColor();\n            this.getContext().strokeStyle = params.getColor();\n            this.getContext().lineWidth = 0.5 * params.getWidth();\n            this.getContext().fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            this.getContext().restore();\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method drawStroke\n     * @param {Stroke} stroke\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStroke = function (stroke, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (stroke && stroke.getLength() > 0) {\n            if (stroke instanceof scope.StrokeComponent) {\n                _renderStroke(stroke, this.getContext());\n            } else {\n                this.drawStart(stroke.getX()[0], stroke.getY()[0]);\n                for (var i = 0; i < stroke.getLength(); ++i) {\n                    this.drawContinue(stroke.getX()[i], stroke.getY()[i], context, parameters);\n                }\n                this.drawEnd(stroke.getX()[stroke.getLength() - 1], stroke.getY()[stroke.getLength() - 1], context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw stroke components\n     *\n     * @private\n     * @method drawStrokes\n     * @param {Stroke[]} strokes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStrokes = function (strokes, context, parameters) {\n        for (var i = 0; i < strokes.length; i++) {\n            this.drawStroke(strokes[i], context, parameters);\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    /**\n     * DEPRECATED METHODS\n     */\n\n    /**\n     * Record the beginning of drawing\n     *\n     * @deprecated\n     * @method drawStart\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStart = function (x, y, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        this.points = [];\n        this.drawing = true;\n        this.points.push(new scope.QuadraticPoint({x: x, y: y}));\n    };\n\n    /**\n     * Record the drawing\n     *\n     * @deprecated\n     * @method drawContinue\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawContinue = function (x, y, context, parameters) {\n        if (this.drawing) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            var params = this.getParameters();\n            var delta = 2 + (params.getWidth() / 4);\n            var last = this.points[this.points.length - 1];\n\n            if (Math.abs(last.getX() - x) >= delta || Math.abs(last.getY() - y) >= delta) {\n\n                if (this.points.length === 1) { // firstPoint\n\n                    var pA = this.points[this.points.length - 1]; // firstPoint\n                    var pB = new scope.QuadraticPoint({x: x, y: y});\n                    var pAB = new scope.QuadraticPoint({\n                        x: 0.5 * (pA.getX() + pB.getX()),\n                        y: 0.5 * (pA.getY() + pB.getY())\n                    });\n                    _computePointParameters(pA, pAB, params.getPressureType());\n                    _computePointParameters(pAB, pB, params.getPressureType());\n\n                    _computeFirstControls(pA, pAB, params.getWidth());\n                    _computeControls(pAB, pB, params.getWidth());\n\n                    this.points.push(pAB);\n                    this.points.push(pB);\n\n                    _drawFirstSegment(pA, pAB, this.getContext(), params);\n\n                } else {\n                    var pAB = this.points[this.points.length - 2]; // jshint ignore:line\n                    var pB = this.points[this.points.length - 1]; // jshint ignore:line\n                    var pC = new scope.QuadraticPoint({x: x, y: y});\n                    var pBC = new scope.QuadraticPoint({\n                        x: 0.5 * (pB.getX() + pC.getX()),\n                        y: 0.5 * (pB.getY() + pC.getY())\n                    });\n                    _computePointParameters(pB, pBC, params.getPressureType());\n                    _computePointParameters(pBC, pC, params.getPressureType());\n\n                    _computeControls(pB, pBC, params.getWidth());\n                    _computeControls(pBC, pC, params.getWidth());\n\n                    this.points.push(pBC);\n                    this.points.push(pC);\n\n                    _drawSegment(pAB, pB, pBC, this.getContext(), params);\n                }\n            }\n        }\n    };\n\n    /**\n     * Stop record of drawing\n     *\n     * @deprecated\n     * @method drawEnd\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawEnd = function (x, y, context, parameters) {\n        if (this.drawing) {\n            var params = this.getParameters();\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            if (this.points.length === 1) {\n                _drawPoint(new scope.QuadraticPoint({x: x, y: y}), this.getContext(), params);\n            } else if (this.points.length > 1) {\n                var pA = this.points[this.points.length - 1];\n                var pB = new scope.QuadraticPoint({x: x, y: y});\n                var pAB = new scope.QuadraticPoint({\n                    x: 0.5 * (pA.getX() + pB.getX()),\n                    y: 0.5 * (pA.getY() + pB.getY())\n                });\n                _computePointParameters(pA, pAB, params.getPressureType());\n                _computePointParameters(pAB, pB, params.getPressureType());\n\n                _computeControls(pA, pAB, params.getWidth());\n                _computeLastControls(pB, params.getWidth());\n\n                this.points.push(pAB);\n                this.points.push(pB);\n\n                _drawLastSegment(pAB, pB, this.getContext(), params);\n            }\n            this.drawing = false;\n        }\n    };\n\n    /**\n     * Draw point on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawPoint\n     * @param {QuadraticPoint} point\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawPoint = function (point, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.arc(point.getX(), point.getY(), 0.25 * parameters.getWidth(), 0, 2 * Math.PI);\n            context.fill();\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw the first stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawFirstSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawFirstSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw middle stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {QuadraticPoint} pC\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawSegment = function (pA, pB, pC, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.quadraticCurveTo(pB.getP1().getX(), pB.getP1().getY(), pC.getP1().getX(), pC.getP1().getY());\n            context.lineTo(pC.getP2().getX(), pC.getP2().getY());\n            context.quadraticCurveTo(pB.getP2().getX(), pB.getP2().getY(), pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw the last stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawLastSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLastSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Compute distance and unit vector from the previous point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePointParameters\n     * @param {QuadraticPoint} previous\n     * @param {QuadraticPoint} point\n     * @param {String} pressureType\n     */\n    var _computePointParameters = function (previous, point, pressureType) {\n        var dx = point.getX() - previous.getX(),\n            dy = point.getY() - previous.getY(),\n            d = Math.sqrt((dx * dx) + (dy * dy));\n\n        if (d !== 0) {\n            point.setDistance(d);\n            point.setCos(dx / d);\n            point.setSin(dy / d);\n        }\n        point.setLength(previous.getLength() + point.getDistance());\n\n        switch (pressureType) {\n            case 'SIMULATED':\n                _computePressure(point);\n                break;\n            case 'CONSTANT':\n                point.setPressure(1.0);\n                break;\n            case 'REAL':\n                // keep the current pressure\n                break;\n            default:\n                throw new Error('Unknown pressure type');\n        }\n    };\n\n    /**\n     * Compute simulated pressure of given point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePressure\n     * @param {QuadraticPoint} point\n     */\n    var _computePressure = function (point) {\n        var k, pressure;\n        if (point.getDistance() < 10) {\n            k = 0.2 + Math.pow(0.1 * point.getDistance(), 0.4);\n        } else if (point.getDistance() > point.getLength() - 10) {\n            k = 0.2 + Math.pow(0.1 * (point.getLength() - point.getDistance()), 0.4);\n        } else {\n            k = 1.0;\n        }\n\n        pressure = k * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(point.getDistance()));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        point.setPressure(pressure);\n    };\n\n    /**\n     * Compute control points of the first point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeFirstControls\n     * @param {QuadraticPoint} first First point of the list to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeFirstControls = function (first, next, penWidth) {\n        var r = 0.5 * (penWidth * first.getPressure()),\n            nx = r * next.getSin(),\n            ny = r * next.getCos();\n\n        first.getP1().setX(first.getX() - nx);\n        first.getP1().setY(first.getY() + ny);\n        first.getP2().setX(first.getX() + nx);\n        first.getP2().setY(first.getY() - ny);\n    };\n\n    /**\n     * Compute control points between two points.\n     *\n     * @private\n     * @deprecated\n     * @method _computeControls\n     * @param {QuadraticPoint} point Point to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeControls = function (point, next, penWidth) {\n        var cos = point.getCos() + next.getCos(),\n            sin = point.getSin() + next.getSin(),\n            u = Math.sqrt((cos * cos) + (sin * sin));\n\n        if (u !== 0) {\n            // compute control points\n            var r = 0.5 * penWidth * point.getPressure();\n            var nx = -r * sin / u;\n            var ny = r * cos / u;\n            point.getP1().setX(point.getX() + nx);\n            point.getP1().setY(point.getY() + ny);\n            point.getP2().setX(point.getX() - nx);\n            point.getP2().setY(point.getY() - ny);\n        }\n    };\n\n    /**\n     * Compute control points of the last point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeLastControls\n     * @param {QuadraticPoint} last Last point to be computed\n     * @param {Number} penWidth Pen width\n     */\n    var _computeLastControls = function (last, penWidth) {\n        var r = 0.5 * penWidth * last.getPressure(),\n            nx = -r * last.getSin(),\n            ny = r * last.getCos();\n\n        last.getP1().setX(last.getX() + nx);\n        last.getP1().setY(last.getY() + ny);\n        last.getP2().setX(last.getX() - nx);\n        last.getP2().setY(last.getY() - ny);\n    };\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (inputUnits, recognitionResult, context, parameters) {\n        this.drawInputUnits(inputUnits, context, parameters);\n    };\n\n    /**\n     * Draw input units\n     *\n     * @method drawInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawInputUnits = function (inputUnits, context, parameters) {\n        for (var i in inputUnits) {\n            this.drawComponents(inputUnits[i].getComponents(), context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @deprecated\n     * @method drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawTextComponent = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawTextComponent(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (this.isTypesetting()) {\n            this.drawShapes(components, recognitionResult.getSegments(), context, parameters);\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes, context, parameters) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawShapeNotRecognized(components, segment.getInkRanges(), context, parameters);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @deprecated\n     * @method drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeRecognized(shapeRecognized, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges, context, parameters) {\n        var notRecognized = _extractShapeNotRecognized(components, inkRanges);\n        this.drawComponents(notRecognized, context, parameters);\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @deprecated\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @deprecated\n     * @method drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeLine = function (shapeLine, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeLine(shapeLine, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @deprecated\n     * @method drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeEllipse(shapeEllipse, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Get strokes from shape inkRange\n     *\n     * @deprecated\n     * @method extractStroke\n     * @param {Stroke[]} strokes\n     * @param {ShapeInkRange} inkRange\n     * @result {Stroke[]} List of strokes from inkRange\n     */\n    ShapeRenderer.prototype.extractStroke = function (strokes, inkRange) {\n        return _extractShapeNotRecognized(strokes, inkRange);\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {*}\n     */\n    var _extractShapeNotRecognized = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.Stroke(), x = [], y = [];\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    x.push(currentStroke.getX()[pointIndex]);\n                    y.push(currentStroke.getY()[pointIndex]);\n                }\n\n                newStroke.setX(x);\n                newStroke.setY(y);\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMathScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MathScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MathRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMathScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMathScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getErasedInkRanges()[n].getComponent());\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getInkRanges()[p].getComponent());\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MusicScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MusicRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMusicScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawStaff = function (staff, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw music node\n     *\n     * @method drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawMusicNode = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawMusicNode(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (this.isTypesetting()) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes(), context, parameters);\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component, context, parameters);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @deprecated\n     * @method drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTables = function (components, tables, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in tables) {\n            if (this.getShowBoundingBoxes()) {\n                for (var j in tables[i].getCells()) {\n                    _drawCell(tables[i].getCells()[j], this.getContext(), this.getParameters());\n                }\n            }\n        }\n        _drawTables(components, tables, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @deprecated\n     * @method drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTextLines = function (components, textLines, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data && this.getShowBoundingBoxes()) {\n                this.drawRectangle(data.getBoundingBox(), context, parameters);\n            }\n        }\n        _drawTextLines(components, textLines, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @deprecated\n     * @method drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawText(boundingBox, text, justificationType, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Underline\n     *\n     * @deprecated\n     * @method drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawUnderline(boundingBox, underline, text, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @deprecated\n     * @method drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        _drawGroups(components, groups, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @deprecated\n     * @method drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n            _drawCell(cell, this.getContext(), this.getParameters());\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Image Renderer. It's used to calculate the Image ink rendering in HTML5 canvas\n     *\n     * @class ImageRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ImageRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ImageRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ImageRenderer.prototype.constructor = ImageRenderer;\n\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ImageRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                console.log(components)\n                console.log(typeof component)\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    // Export\n    scope.ImageRenderer = ImageRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n\n\n\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n        this.canvasRatio = 1;\n\n        // Capture\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n        this.canvasRatio = _getCanvasRatio(this._renderingCanvas);\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer();\n        this._mathRecognizer = new scope.MathRecognizer();\n        this._shapeRecognizer = new scope.ShapeRecognizer();\n        this._musicRecognizer = new scope.MusicRecognizer();\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer();\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this));\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this));\n\n        this._attachListeners(element);\n\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            ssl: true,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        // Recognition type\n        this.setType(this.options.type);\n\n        this.setHost(this.options.host);\n        this.setSSL(this.options.ssl);\n\n        this.setTextParameters(this.options.textParameters); // jshint ignore:line\n        this.setMathParameters(this.options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(this.options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(this.options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(this.options.analyzerParameters); // jshint ignore:line\n\n        this.setProtocol(this.options.protocol);\n        this.setTimeout(this.options.timeout);\n        this.setApplicationKey(this.options.applicationKey);\n        this.setHmacKey(this.options.hmacKey);\n\n        this.setPenParameters(this.options.penParameters);\n\n        this.setPrecision(this.options.precision);\n        this.setTypeset(this.options.typeset);\n        this.setComponents(this.options.components);\n\n        this.setWidth(this.options.width);\n        this.setHeight(this.options.height);\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        if(width > 0){\n            this._captureCanvas.width = width * this.canvasRatio;\n            this._captureCanvas.style.width = width + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.width = width * this.canvasRatio;\n            this._renderingCanvas.style.width = width + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        if(height > 0){\n            this._captureCanvas.height = height * this.canvasRatio;\n            this._captureCanvas.style.height = height + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.height = height * this.canvasRatio;\n            this._renderingCanvas.style.height = height + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Set the recognition precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    InkPaper.prototype.setPrecision = function (precision) {\n        this._textRecognizer.setPrecision(precision);\n        this._textWSRecognizer.setPrecision(precision);\n        this._mathRecognizer.setPrecision(precision);\n        this._mathWSRecognizer.setPrecision(precision);\n        this._shapeRecognizer.setPrecision(precision);\n        this._musicRecognizer.setPrecision(precision);\n        this._analyzerRecognizer.setPrecision(precision);\n    };\n\n    /**\n     * Get the default components\n     *\n     * @method getComponents\n     * @return {Array} components\n     */\n    InkPaper.prototype.getComponents = function () {\n        return this.options.components;\n    };\n\n    /**\n     * Set the default components\n     *\n     * @method setComponents\n     * @param {Array} components\n     */\n    InkPaper.prototype.setComponents = function (components) {\n        this.options.components = components;\n        this._initRenderingCanvas();\n    };\n\n\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @deprecated Use setTextParameters instead\n     * @method setLanguage\n     * @param  String language\n     */\n    InkPaper.prototype.setLanguage = function (language) {\n        if (this.options.type === scope.RecognitionType.TEXT) {\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setLanguage(language);\n        }\n    };\n\n    /**\n     * Set math recognition format result types\n     *\n     * @deprecated Use setMathParameters instead\n     * @method setResultTypes\n     * @param  Array resultTypes\n     */\n    InkPaper.prototype.setResultTypes = function (resultTypes) {\n        if (this.options.type === scope.RecognitionType.MATH) {\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setResultTypes(resultTypes.map(function (x) {\n                return x.toUpperCase();\n            }));\n        }\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n            this._initRenderingCanvas();\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @param {String} [inputMode] input mode\n     */\n    InkPaper.prototype.getAvailableLanguages = function (inputMode) {\n        this._selectedRESTRecognizer.getAvailableLanguageList(\n            this.getApplicationKey(),\n            inputMode ? inputMode : this._textRecognizer.getParameters().getInputMode()\n        ).then(\n            function (data) {\n                this._onResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the recognition callback\n     *\n     * @method setCallback\n     * @deprecated Use setResultCallback instead\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     */\n    InkPaper.prototype.setCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        return this._doRecognition(this.components);\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this.components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            this.redoComponents.push(this.components.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this.redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this.components.push(this.redoComponents.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            if (this._instanceId) {\n                this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                this._instanceId = undefined;\n            }\n        }\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this._inkGrabber.clear();\n        this._instanceId = undefined;\n\n        this._initRenderingCanvas();\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n        var sizeChanged = false;\n        if (this._captureCanvas.clientHeight != this._captureCanvas.height) {\n            this._captureCanvas.height = this._captureCanvas.clientHeight;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight;\n            sizeChanged = true;\n        }\n\n        if (this._captureCanvas.clientWidth != this._captureCanvas.width) {\n            this._captureCanvas.width = this._captureCanvas.clientWidth;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth;\n            sizeChanged = true;\n        }\n\n        //Safari trash the canvas content when heigth or width are modified.\n        if(sizeChanged){\n            this._initRenderingCanvas();\n        }\n\n        if (this.canRedo()) {\n            this.redoComponents = [];\n            this._onChange();\n        }\n\n        this._inkGrabber.startCapture(x, y, t);\n\n\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this.components.push(stroke);\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            }\n        }\n    };\n\n    /**\n     * Do recognition\n     *\n     * @private\n     * @method _doRecognition\n     * @param {AbstractComponent[]} components Input components\n     */\n    InkPaper.prototype._doRecognition = function (components) {\n        if (components.length > 0) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                if (this._initialized) {\n                    var inputWS = [];\n                    if (this._selectedRecognizer instanceof scope.TextWSRecognizer) {\n                        var inputUnitWS = new scope.TextInputUnit();\n                        inputUnitWS.setComponents(this.getComponents().concat(components.slice(this.lastNonRecoComponentIdx)));\n                        inputWS = [inputUnitWS];\n                    } else {\n                        inputWS = components.slice(this.lastNonRecoComponentIdx);\n                    }\n                    this.lastNonRecoComponentIdx = components.length;\n\n\n                    if (this.isStarted) {\n                        this._selectedRecognizer.continueWSRecognition(inputWS, this._instanceId);\n                    } else {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(inputWS);\n                    }\n                }\n            } else {\n                var input = [];\n                if (this._selectedRecognizer instanceof scope.TextRecognizer) {\n                    var inputUnit = new scope.TextInputUnit();\n                    inputUnit.setComponents(this.getComponents().concat(components));\n                    input = [inputUnit];\n                } else if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                    input = components.slice(this.lastNonRecoComponentIdx);\n                    this.lastNonRecoComponentIdx = components.length;\n                } else {\n                    input = input.concat(this.getComponents(), components);\n                }\n                this._selectedRecognizer.doSimpleRecognition(\n                    this.getApplicationKey(),\n                    this._instanceId,\n                    input,\n                    this.getHmacKey()\n                ).then(\n                    function (data) {\n                        this._parseResult(data, input);\n                    }.bind(this),\n                    function (error) {\n                        this._onResult(undefined, error);\n                    }.bind(this)\n                );\n            }\n        } else {\n            this.isStarted = false;\n            this._selectedRenderer.clear();\n            this._initRenderingCanvas();\n            this._onResult();\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('failure', {detail: err})); // FIXME: mark as deprecated\n            this._element.dispatchEvent(new CustomEvent('error', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function () {\n        var data = {\n            canUndo: this.canUndo(),\n            undoLength: this.components.length,\n            canRedo: this.canRedo(),\n            redoLength: this.redoComponents.length\n        };\n\n        if (this.changeCallback) {\n            this.changeCallback(data)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: data}));\n    };\n\n    InkPaper.prototype._parseResult = function (data, input) {\n\n        if (!this._instanceId) {\n            this._instanceId = data.getInstanceId();\n        } else if (this._instanceId !== data.getInstanceId()) {\n            this._onResult(data);\n            return data;\n        }\n\n        if (data.getDocument().hasScratchOutResults() || this._selectedRenderer.isTypesetting()) {\n            this._selectedRenderer.clear();\n            this._selectedRenderer.drawRecognitionResult(input, data.getDocument());\n        }\n\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service url\n     *\n     * @param {String} host\n     */\n    InkPaper.prototype.setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._textWSRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._mathWSRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * @private\n     */\n    InkPaper.prototype.setSSL = function (ssl) {\n        this._textRecognizer.setSSL(ssl);\n        this._textWSRecognizer.setSSL(ssl);\n        this._mathRecognizer.setSSL(ssl);\n        this._mathWSRecognizer.setSSL(ssl);\n        this._shapeRecognizer.setSSL(ssl);\n        this._musicRecognizer.setSSL(ssl);\n        this._analyzerRecognizer.setSSL(ssl);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n\n        //Desactivation of contextmenu to prevent safari to fire pointerdown only once\n        element.addEventListener(\"contextmenu\", function(e){\n            e.preventDefault();\n            e.stopPropagation();\n            return false; }\n        );\n\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n        this._drawInput(this.components);\n    };\n\n    InkPaper.prototype._drawInput = function (components) {\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        this._selectedRenderer.drawComponents(this.getComponents().concat(components));\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this.lastNonRecoComponentIdx = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge(this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    break;\n                default:\n                    this._parseResult(message, this.components);\n                    break;\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Return the stats allowing to monitor what ink size is send to the server.\n     * @returns Stats objects format {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'} humanUnit could have the values BYTE, BYTES, KiB, MiB\n     */\n    InkPaper.prototype.getStats = function () {\n        var stats = {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'};\n        if(this.components){\n            stats.strokesCount = this.components.length;\n            var pointsCount = 0;\n            for(var strokeNb = 0; strokeNb < this.components.length; strokeNb++){\n                pointsCount = pointsCount + this.components[strokeNb].x.length;\n            }\n            stats.strokesCount = this.components.length;\n            stats.pointsCount = pointsCount;\n            //We start with 270 as it is the size in bytes. Make a real computation implies to recode a doRecogntion\n            var byteSize = 270;\n            byteSize = JSON.stringify(this.components).length;\n            stats.byteSize = byteSize;\n            if (byteSize < 270) {\n                stats.humanUnit = 'BYTE';\n                stats.byteSize = 0;\n                stats.humanSize  = 0;\n            } else if (byteSize < 2048) {\n                stats.humanUnit = 'BYTES';\n                stats.humanSize  = byteSize;\n            } else if (byteSize < 1024 * 1024) {\n                stats.humanUnit = 'KiB';\n                stats.humanSize = (byteSize / 1024).toFixed(2);\n            } else {\n                stats.humanUnit = 'MiB';\n                stats.humanSize = (byteSize / 1024 / 1024).toFixed(2);\n            }\n        }\n        return stats;\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {ImageData} Build an ImageData object with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsImageData = function (marginX, marginY) {\n        if(!marginX){\n            marginX = 10;\n        }\n        if(!marginY){\n            marginY = 10;\n        }\n        console.log({marginX : marginX, marginY : marginY});\n        if(this.components && this.components.length > 0){\n            var updatedStrokes ;\n            var strokesCount = this.components.length;\n            //Initializing min and max\n            var minX = this.components[0].x[0];\n            var maxX = this.components[0].x[0];\n            var minY = this.components[0].y[0];\n            var maxY = this.components[0].y[0];\n            // Computing the min and max for x and y\n            for(var strokeNb = 0; strokeNb < this.components.length; strokeNb++){\n                var pointCount = this.components[strokeNb].x.length;\n                for(var pointNb = 0; pointNb < pointCount; pointNb ++){\n                    var currentX = this.components[strokeNb].x[pointNb];\n                    var currentY = this.components[strokeNb].y[pointNb];\n                    if(currentX < minX){\n                        minX = currentX;\n                    }\n                    if(currentX > maxX){\n                        maxX = currentX;\n                    }\n                    if(currentY < minY){\n                        minY = currentY;\n                    }\n                    if(currentY > maxY){\n                        maxY = currentY;\n                    }\n                }\n            }\n            var nonDisplayCanvas = document.createElement('canvas');\n            nonDisplayCanvas.width = (maxX )+(2*marginX);\n            nonDisplayCanvas.height = (maxY )+(2*marginY)\n\n            var ctx =  nonDisplayCanvas.getContext(\"2d\");\n\n            var imageRendered = new scope.ImageRenderer(ctx);\n            imageRendered.drawComponents(this.components, ctx);\n\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData\n            var imageData = ctx.getImageData(minX-marginX, minY-marginY, (maxX-minX )+(2*marginX), (maxY-minY )+(2*marginY));\n            return imageData;\n        } else {\n            return;\n        }\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {String} Build an String containg dataUrl with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsPng = function (marginX, marginY) {\n        var imageRenderingCanvas = document.createElement('canvas');\n        imageRenderingCanvas.style.display = 'none';\n\n        var imageDataToRender = this.getInkAsImageData();\n        imageRenderingCanvas.width = imageDataToRender.width;\n        imageRenderingCanvas.style.width = imageDataToRender.width +'px';\n        imageRenderingCanvas.height = imageDataToRender.height;\n        imageRenderingCanvas.style.height = imageDataToRender.height +'px';\n        var ctx = imageRenderingCanvas.getContext('2d');\n        ctx.putImageData(imageDataToRender, 0, 0);\n        var ret = imageRenderingCanvas.toDataURL(\"image/png\");\n        return ret;\n    }\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n    /**\n     * Tool to get canvas ratio (retina display)\n     *\n     * @private\n     * @param {Element} canvas\n     * @returns {Number}\n     */\n    function _getCanvasRatio(canvas) {\n        if (canvas) {\n            var context = canvas.getContext('2d'),\n                devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                    context.mozBackingStorePixelRatio ||\n                    context.msBackingStorePixelRatio ||\n                    context.oBackingStorePixelRatio ||\n                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        }\n        return 1;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n","/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE',\n            OFFICEOPENXMLMATH : 'OFFICEOPENXMLMATH'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n","'use strict';\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Complex Point object used for quadratic calculation\n     *\n     * @deprecated\n     * @class QuadraticPoint\n     * @extends Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function QuadraticPoint(obj) {\n        scope.Point.call(this, obj);\n        this.pressure = 0.5;\n        this.distance = 0.0;\n        this.length = 0.0;\n        this.cos = 0.0;\n        this.sin = 0.0;\n        this.p1 = new scope.Point(obj);\n        this.p2 = new scope.Point(obj);\n        if (obj) {\n            this.pressure = obj.pressure;\n            this.distance = obj.distance;\n            this.length = obj.length;\n            this.cos = obj.cos;\n            this.sin = obj.sin;\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    QuadraticPoint.prototype = new scope.Point();\n\n    /**\n     * Constructor property\n     */\n    QuadraticPoint.prototype.constructor = QuadraticPoint;\n\n    /**\n     * Get pressure\n     *\n     * @method getPressure\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getPressure = function () {\n        return this.pressure;\n    };\n\n    /**\n     * Set pressure\n     *\n     * @method setPressure\n     * @param {Number} pressure\n     */\n    QuadraticPoint.prototype.setPressure = function (pressure) {\n        this.pressure = pressure;\n    };\n\n    /**\n     * Get distance\n     *\n     * @method getDistance\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getDistance = function () {\n        return this.distance;\n    };\n\n    /**\n     * Set distance\n     *\n     * @method setDistance\n     * @param {Number} distance\n     */\n    QuadraticPoint.prototype.setDistance = function (distance) {\n        this.distance = distance;\n    };\n\n    /**\n     * Get length\n     *\n     * @method getLength\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getLength = function () {\n        return this.length;\n    };\n\n    /**\n     * Set length\n     *\n     * @method setLength\n     * @param {Number} length\n     */\n    QuadraticPoint.prototype.setLength = function (length) {\n        this.length = length;\n    };\n\n    /**\n     * Get cos\n     *\n     * @method getCos\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getCos = function () {\n        return this.cos;\n    };\n\n    /**\n     * Set cos\n     *\n     * @method setCos\n     * @param {Number} cos\n     */\n    QuadraticPoint.prototype.setCos = function (cos) {\n        this.cos = cos;\n    };\n\n    /**\n     * Get sin\n     *\n     * @method getSin\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getSin = function () {\n        return this.sin;\n    };\n\n    /**\n     * Set sin\n     *\n     * @method setSin\n     * @param {Number} sin\n     */\n    QuadraticPoint.prototype.setSin = function (sin) {\n        this.sin = sin;\n    };\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Set p1\n     *\n     * @method setP1\n     * @param {Point} p1\n     */\n    QuadraticPoint.prototype.setP1 = function (p1) {\n        this.p1 = p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    /**\n     * Set p2\n     *\n     * @method setP2\n     * @param {Point} p2\n     */\n    QuadraticPoint.prototype.setP2 = function (p2) {\n        this.p2 = p2;\n    };\n\n    // Export\n    scope.QuadraticPoint = QuadraticPoint;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * The InkManager class that can use to store writing strokes and manage the undo/redo/clear system\n     *\n     * @deprecated\n     * @class InkManager\n     * @constructor\n     */\n    function InkManager() {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    }\n\n    /**\n     * Is Writing a stroke\n     *\n     * @deprecated\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last current Stroke write\n     *\n     * @deprecated\n     * @method getCurrentStroke\n     * @returns {Stroke}\n     */\n    InkManager.prototype.getCurrentStroke = function () {\n        return this.currentStroke;\n    };\n\n    /**\n     * Start ink capture\n     *\n     * @deprecated\n     * @method startInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.startInkCapture = function (x, y, t) {\n        if (!this.writing) {\n            if (!this.isRedoEmpty()) {\n                this.clearUndoRedoStack();\n            }\n            this.currentStroke = new scope.Stroke();\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n            this.writing = true;\n        } else {\n            throw new Error('Stroke capture already running');\n        }\n    };\n\n    /**\n     * Continue ink capture\n     *\n     * @deprecated\n     * @method continueInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.continueInkCapture = function (x, y, t) {\n        if (this.writing) {\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * End ink capture\n     *\n     * @deprecated\n     * @method endInkCapture\n     */\n    InkManager.prototype.endInkCapture = function () {\n        if (this.writing) {\n            this.strokes.push(this.currentStroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * Clear the strokes list\n     *\n     * @deprecated\n     * @method clear\n     */\n    InkManager.prototype.clear = function () {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Is The Strokes list is empty\n     *\n     * @deprecated\n     * @method isEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isEmpty = function () {\n        return this.strokes.length === 0;\n    };\n\n    /**\n     * Is the Undo/Redo Stack empty\n     *\n     * @method isRedoEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isRedoEmpty = function () {\n        return this.undoRedoStack.length === 0;\n    };\n\n    /**\n     * Make an undo\n     *\n     * @deprecated\n     * @method undo\n     */\n    InkManager.prototype.undo = function () {\n        if (!this.isEmpty()) {\n            this.undoRedoStack.push(this.strokes.pop());\n        }\n    };\n\n    /**\n     * Make a redo\n     *\n     * @deprecated\n     * @method redo\n     */\n    InkManager.prototype.redo = function () {\n        if (!this.isRedoEmpty()) {\n            this.strokes.push(this.undoRedoStack.pop());\n        }\n    };\n\n    /**\n     * Get the strokes list\n     *\n     * @deprecated\n     * @method getStokes\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getStrokes = function () {\n        return this.strokes;\n    };\n\n    /**\n     * Get the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method getUndoRedoStack\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getUndoRedoStack = function () {\n        return this.undoRedoStack;\n    };\n\n    /**\n     * Clear the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method clearUndoRedoStack\n     */\n    InkManager.prototype.clearUndoRedoStack = function () {\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Copy the strokes values from index on an other list of strokes\n     *\n     * @deprecated\n     * @method copy\n     * @param {Stroke[]} strokes List of strokes\n     * @param {Number} index Position to start the copy\n     */\n    InkManager.prototype.copy = function (strokes, index) {\n        for (index; index < this.strokes.length; index++) {\n            strokes.push(this.strokes[index]);\n        }\n    };\n\n    // Export\n    scope.InkManager = InkManager;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get the pressure renderer parameter\n     *\n     * @deprecated\n     * @method getPressureType\n     * @returns {String} The pressure type\n     */\n    PenParameters.prototype.getPressureType = function () {\n        return this.pressureType;\n    };\n\n    /**\n     * Set the pressure renderer parameter\n     *\n     * @deprecated\n     * @method setPressureType\n     * @param {String} pressureType\n     */\n    PenParameters.prototype.setPressureType = function (pressureType) {\n        this.pressureType = pressureType;\n    };\n\n    /**\n     * Get the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method getAlpha\n     * @returns {String} The alpha\n     */\n    PenParameters.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * Set the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method setAlpha\n     * @param {String} alpha\n     */\n    PenParameters.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @deprecated Use 'PenParameters' instead\n     * @class RenderingParameters\n     * @constructor\n     */\n    function RenderingParameters() {\n        scope.PenParameters.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    RenderingParameters.prototype = new scope.PenParameters();\n\n    /**\n     * Constructor property\n     */\n    RenderingParameters.prototype.constructor = RenderingParameters;\n\n    // Export\n    scope.RenderingParameters = RenderingParameters;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @deprecated Use StrokeComponent instead\n     * @class Stroke\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function Stroke(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        if (obj) {\n            if (obj.x) {\n                this.x = obj.x;\n            }\n            if (obj.y) {\n                this.y = obj.y;\n            }\n            if (obj.t) {\n                this.t = obj.t;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    Stroke.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    Stroke.prototype.constructor = Stroke;\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    Stroke.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    Stroke.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    Stroke.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    Stroke.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    Stroke.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    Stroke.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    Stroke.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    Stroke.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    Stroke.prototype.toFixed = function (precision) {\n        if (precision !== undefined) {\n            for (var i in this.x) {\n                this.x[i] = this.x[i].toFixed(precision);\n                this.y[i] = this.y[i].toFixed(precision);\n            }\n        }\n    };\n\n    // Export\n    scope.Stroke = Stroke;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @class StrokeComponent\n     * @extends Stroke\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.Stroke.call(this);\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            if (obj.p) {\n                this.p = obj.p;\n            }\n            if (obj.d) {\n                this.d = obj.d;\n            }\n            if (obj.l) {\n                this.l = obj.l;\n            }\n            if (obj.color) {\n                this.color = obj.color;\n            }\n            if (obj.alpha) {\n                this.alpha = obj.alpha;\n            }\n            if (obj.width) {\n                this.width = obj.width;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.Stroke();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**     *\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (this.filterPointByAcquisitionDelta(x, y)) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(this.computeP(x, y));\n            this.addD(this.computeD(x, y));\n            this.addL(this.computeL(x, y));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    StrokeComponent.prototype.computeD = function (x, y) {\n        var distance = Math.sqrt(Math.pow((y - this.getY()[this.getLastIndexPoint() - 1]), 2) + Math.pow((x - this.getX()[this.getLastIndexPoint() - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    };\n\n    StrokeComponent.prototype.computeL = function (x, y) {\n        var length = this.getL()[this.getLastIndexPoint() - 1] + this.computeD(x, y);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    };\n\n    StrokeComponent.prototype.computeP = function (x, y) {\n        var ratio = 1.0;\n        var distance = this.computeD(x, y);\n        var length = this.computeL(x, y);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    };\n\n    StrokeComponent.prototype.filterPointByAcquisitionDelta = function (x, y) {\n        var delta = (2 + (this.getWidth() / 4));\n        var ret = false;\n        if (this.getLength() === 0 || Math.abs(this.getX()[this.getLastIndexPoint()] - x) >= delta || Math.abs(this.getY()[this.getLastIndexPoint()] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    };\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n        if (obj) {\n            if (obj.alternates) {\n                for (var i in obj.alternates) {\n                    this.alternates.push(new scope.CharacterInputComponentAlternate(obj.alternates[i]));\n                }\n            }\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(obj) {\n        if (obj) {\n            if (obj.alternate) {\n                this.alternate = obj.alternate;\n            }\n            if (obj.probability) {\n                this.probability = obj.probability;\n            }\n        }\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'char';\n        if (obj) {\n            if (obj.character) {\n                this.character = obj.character;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get character\n     *\n     * @deprecated Use 'getLabel'\n     * @method getCharacter\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getCharacter = function () {\n        return this.character;\n    };\n\n    /**\n     * Set character\n     *\n     * @deprecated Use 'setLabel'\n     * @method setCharacter\n     * @param {String} character\n     */\n    CharInputComponent.prototype.setCharacter = function (character) {\n        this.character = character;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'string';\n        if (obj) {\n            if (obj.string) {\n                this.string = obj.string;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get string\n     *\n     * @deprecated Use 'getLabel'\n     * @method getString\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getString = function () {\n        return this.string;\n    };\n\n    /**\n     * Set string\n     *\n     * @deprecated Use 'setLabel'\n     * @method setString\n     * @param {String} string\n     */\n    StringInputComponent.prototype.setString = function (string) {\n        this.string = string;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n        if (obj) {\n            if (obj.language) {\n                this.language = obj.language;\n            }\n            if (obj.textInputMode) {\n                this.textInputMode = obj.textInputMode;\n            }\n            if (obj.contentTypes) {\n                this.contentTypes = obj.contentTypes;\n            }\n            if (obj.subsetKnowledges) {\n                this.subsetKnowledges = obj.subsetKnowledges;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.userLkWords) {\n                this.userLkWords = obj.userLkWords;\n            }\n            if (obj.resultDetail) {\n                this.resultDetail = obj.resultDetail;\n            }\n            if (obj.textProperties) {\n                this.textProperties = new scope.TextProperties(obj.textProperties);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties(obj) {\n        if (obj) {\n            if (obj.textCandidateListSize) {\n                this.textCandidateListSize = obj.textCandidateListSize;\n            }\n            if (obj.wordCandidateListSize) {\n                this.wordCandidateListSize = obj.wordCandidateListSize;\n            }\n            if (obj.wordPredictionListSize) {\n                this.wordPredictionListSize = obj.wordPredictionListSize;\n            }\n            if (obj.wordCompletionListSize) {\n                this.wordCompletionListSize = obj.wordCompletionListSize;\n            }\n            if (obj.characterCandidateListSize) {\n                this.characterCandidateListSize = obj.characterCandidateListSize;\n            }\n            if (obj.discardCaseVariations) {\n                this.discardCaseVariations = obj.discardCaseVariations;\n            }\n            if (obj.discardAccentuationVariations) {\n                this.discardAccentuationVariations = obj.discardAccentuationVariations;\n            }\n            if (obj.disableSpatialOrdering) {\n                this.disableSpatialOrdering = obj.disableSpatialOrdering;\n            }\n            if (obj.glyphDistortion) {\n                this.glyphDistortion = obj.glyphDistortion;\n            }\n            if (obj.enableOutOfLexicon) {\n                this.enableOutOfLexicon = obj.enableOutOfLexicon;\n            }\n            if (obj.spellingDistortion) {\n                this.spellingDistortion = obj.spellingDistortion;\n            }\n        }\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getTextRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getTextRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setTextRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setTextRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        if (obj) {\n            if (obj.rejectDetectionSensitivity) {\n                this.rejectDetectionSensitivity = obj.rejectDetectionSensitivity;\n            }\n            if (obj.doBeautification) {\n                this.doBeautification = obj.doBeautification;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {ShapeParameter}\n     */\n    ShapeRecognitionInput.prototype.getParameters = function () {\n        return new ShapeParameter({\n            rejectDetectionSensitivity: this.rejectDetectionSensitivity,\n            doBeautification: this.doBeautification,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {ShapeParameter} parameters\n     */\n    ShapeRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.rejectDetectionSensitivity = parameters.getRejectDetectionSensitivity();\n            this.doBeautification = parameters.hasBeautification();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @deprecated Use getParameters instead of getDoBeautification\n     * @method getDoBeautification\n     * @returns {Boolean}\n     */\n    ShapeRecognitionInput.prototype.getDoBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @deprecated Use setParameters instead of setDoBeautification\n     * @method setDoBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeRecognitionInput.prototype.setDoBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @deprecated Use getParameters instead of getRejectDetectionSensitivity\n     * @method getRejectDetectionSensitivity\n     * @returns {Number}\n     */\n    ShapeRecognitionInput.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @deprecated Use setParameters instead of setRejectDetectionSensitivity\n     * @method setRejectDetectionSensitivity\n     * @param {Number} rejectDetectionSensitivity\n     */\n    ShapeRecognitionInput.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getShapeRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getShapeRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setShapeRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setShapeRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n            if (obj.columnarOperation) {\n                this.columnarOperation = obj.columnarOperation;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathRecognitionInput.prototype.getParameters = function () {\n        return new MathParameter({\n            resultTypes: this.resultTypes,\n            columnarOperation: this.columnarOperation,\n            userResources: this.userResources,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.resultTypes = parameters.getResultTypes();\n            this.columnarOperation = parameters.isColumnar();\n            this.userResources = parameters.getUserResources();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @deprecated Use getParameters instead of getResultTypes\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @deprecated Use setParameters instead of setResultTypes\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @deprecated Use getParameters instead of isColumnar\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathRecognitionInput.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @deprecated Use setParameters instead of setColumnar\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathRecognitionInput.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @deprecated Use getParameters instead of getUserResources\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @deprecated Use setParameters instead of setUserResources\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use getParameters instead of getScratchOutDetectionSensitivity\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use setParameters instead of setScratchOutDetectionSensitivity\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n    /**\n     * Get math input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMathRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getMathRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMathRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setMathRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'accidental';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'arpeggiate';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBar(obj.value);\n            }\n        }\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBeam(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicClef(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicDecoration(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'dots';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'head';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'rest';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'stem';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'tieOrSlur';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'timeSignature';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff(obj) {\n        this.count = 5;\n        this.gap = 20;\n        if (obj) {\n            if (obj.count) {\n                this.count = obj.count;\n            }\n            if (obj.gap) {\n                this.gap = obj.gap;\n            }\n            if (obj.top) {\n                this.top = obj.top;\n            }\n        }\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.divisions) {\n                this.divisions = obj.divisions;\n            }\n            if (obj.staff) {\n                this.staff = new scope.MusicStaff(obj.staff);\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MusicParameter}\n     */\n    MusicRecognitionInput.prototype.getParameters = function () {\n        return new MusicParameter({\n            divisions: this.divisions,\n            staff: this.staff,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity,\n            resultTypes: this.resultTypes,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MusicParameter} parameters\n     */\n    MusicRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.divisions = parameters.getDivisions();\n            this.staff = parameters.getStaff();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n            this.resultTypes = parameters.getResultTypes();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the result types\n     *\n     * @deprecated Use getParameters instead of getResultTypes\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the result types\n     *\n     * @deprecated Use setParameters instead of setResultTypes\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @deprecated Use getParameters instead of getUserResources\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @deprecated Use setParameters instead of setUserResources\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use getParameters instead of getScratchOutDetectionSensitivity\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @deprecated Use setParameters instead of setScratchOutDetectionSensitivity\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @deprecated Use getParameters instead of getStaff\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicRecognitionInput.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @deprecated Use setParameters instead of setStaff\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRecognitionInput.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @deprecated Use getParameters instead of getDivisions\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @deprecated Use setParameters instead of setDivisions\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicRecognitionInput.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMusicRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getMusicRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMusicRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setMusicRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n        if (obj) {\n            if (obj.coordinateResolution) {\n                this.coordinateResolution = obj.coordinateResolution;\n            }\n            if (obj.textParameter) {\n                this.textParameter = new scope.TextParameter(obj.textParameter);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getAnalyzerRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getAnalyzerRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setAnalyzerRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setAnalyzerRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            if (typeof obj === 'string') {\n                var cpt = obj.split(/[:-]+/);\n                this.startUnit = Number(cpt[0]);\n                this.startComponent = Number(cpt[1]);\n                this.startPoint = Number(cpt[2]);\n                this.endUnit = Number(cpt[3]);\n                this.endComponent = Number(cpt[4]);\n                this.endPoint = Number(cpt[5]);\n            } else {\n                this.startUnit = obj.startUnit;\n                this.startComponent = obj.startComponent;\n                this.startPoint = obj.startPoint;\n                this.endUnit = obj.endUnit;\n                this.endComponent = obj.endComponent;\n                this.endPoint = obj.endPoint;\n            }\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordCandidates = [];\n        this.charCandidates = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordCandidates) {\n                this.wordCandidates.push(new scope.TextSegment(obj.wordCandidates[j]));\n            }\n            for (var k in obj.charCandidates) {\n                this.charCandidates.push(new scope.TextSegment(obj.charCandidates[k]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordCandidates;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charCandidates;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResult.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResponseWSMessage.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    /**\n     * Get shape document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getShapeDocument\n     * @returns {ShapeDocument}\n     */\n    ShapeResult.prototype.getShapeDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);","(function (scope) {\n    'use strict';\n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    case 'OFFICEOPENXMLMATH':\n                        this.results.push(new scope.MathOfficeOpenXmlMathResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MathOfficeOpenXmlMathResultElement result element\n     *\n     * @class MathOfficeOpenXmlMathResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathOfficeOpenXmlMathResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n\n    /**\n     * Inheritance property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.constructor = MathOfficeOpenXmlMathResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathOfficeOpenXmlMathResultElement = MathOfficeOpenXmlMathResultElement;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResult.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResponseWSMessage.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    /**\n     * Get music document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMusicDocument\n     * @returns {MusicDocument}\n     */\n    MusicResult.prototype.getMusicDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    /**\n     * Get analyzer document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getAnalyzerDocument\n     * @returns {AnalyzerDocument}\n     */\n    AnalyzerResult.prototype.getAnalyzerDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);","'use strict';\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    NetworkInterface.parseURL = function (url) {\n\n        var parser = document.createElement('a'),\n            searchObject = {},\n            queries, split, i;\n        // Let the browser do the work\n        parser.href = url;\n        // Convert query string to object\n        queries = parser.search.replace(/^\\?/, '').split('&');\n        for (i = 0; i < queries.length; i++) {\n            split = queries[i].split('=');\n            searchObject[split[0]] = split[1];\n        }\n        return {\n            protocol: parser.protocol,\n            host: parser.host,\n            hostname: parser.hostname,\n            port: parser.port,\n            pathname: parser.pathname,\n            search: parser.search,\n            searchObject: searchObject,\n            hash: parser.hash\n        };\n    };\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        return Q.Promise(function (resolve, reject, notify) {\n\n            function onStateChange() {\n                if (request.readyState === 4) {\n                    if (request.status >= 200 && request.status < 300) {\n                        resolve(NetworkInterface.parse(request));\n                    }\n                }\n            }\n\n            function onLoad() {\n                if (request.status >= 200 && request.status < 300) {\n                    resolve(NetworkInterface.parse(request));\n                } else {\n                    reject(new Error(request.responseText));\n                }\n            }\n\n            function onError() {\n                reject(new Error('Can\\'t XHR ' + url));\n            }\n\n            function onProgress(e) {\n                notify(e.loaded / e.total);\n            }\n\n            var request = new XMLHttpRequest();\n            request.open(type, url, true);\n            request.withCredentials = true;\n            request.setRequestHeader('Accept', 'application/json');\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            request.onerror = onError;\n            request.onprogress = onProgress;\n            request.onload = onLoad;\n            request.onreadystatechange = onStateChange;\n            request.send(NetworkInterface.transformRequest(data));\n        });\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n","'use strict';\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface() {\n    }\n\n    NetworkWSInterface.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.close();\n            this._url = url;\n        }\n    };\n\n    NetworkWSInterface.prototype.getUrl = function () {\n        return this._url;\n    };\n\n    NetworkWSInterface.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this.close();\n            this._callback = callback;\n        }\n    };\n\n    NetworkWSInterface.prototype.getCallback = function () {\n        return this._callback;\n    };\n\n    NetworkWSInterface.prototype.getState = function () {\n        return _getWebSocketState(this._socket);\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        return this.getState() === 3;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        return this.getState() === 2;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        return this.getState() === 1;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        return this.getState() === 0;\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        if (this.getUrl() && this.getCallback() && ((this.getState() < 0) || this.isClosed())) {\n            this._socket = _openWebSocket(this.getUrl(), this.getCallback());\n        }\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this.getState() < 2) {\n            _closeWebSocket(this._socket, code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.send = function (request) {\n        var state = _getWebSocketState(this._socket);\n        if (state  === 1) {\n            _sendMessage(this._socket, request);\n        }\n    };\n\n    /**\n     *\n     * @param url\n     * @param callback\n     * @returns {WebSocket}\n     * @private\n     */\n    var _openWebSocket = function (url, callback) {\n        function onOpen(e) {\n            callback(e);\n        }\n        function onClose(e) {\n            callback(e);\n        }\n        function onError(e) {\n            callback(e);\n        }\n        function onMessage(e) {\n            callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        }\n\n        var socket = new WebSocket(url);\n        socket.onopen = onOpen;\n        socket.onclose = onClose;\n        socket.onerror = onError;\n        socket.onmessage = onMessage;\n        return socket;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param code\n     * @param reason\n     * @private\n     */\n    var _closeWebSocket = function (socket, code, reason) {\n        if (socket) {\n            socket.close(code, reason);\n        }\n    };\n\n    /**\n     *\n     * @param socket\n     * @returns {*}\n     * @private\n     */\n    var _getWebSocketState = function (socket) {\n        if (socket) {\n            return socket.readyState;\n        }\n        return -1;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param message\n     * @private\n     */\n    var _sendMessage = function (socket, message) {\n        if (socket) {\n            socket.send(JSON.stringify(message));\n        }\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n","'use strict';\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n    }\n\n    AbstractRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'https://': 'http://';\n    };\n\n    AbstractRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getUrl\n     * @returns {String}\n     */\n    AbstractRecognizer.prototype.getUrl = function() {\n        return this.url;\n    };\n\n    /**\n     * Set the recognition service url\n     *\n     * @method setUrl\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.url = url;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get(this.getUrl() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @private\n     * @method doRestRecognition\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (input, applicationKey, hmacKey, instanceId) {\n        if (input.getComponents) {\n            _filterStrokes(input.getComponents(), this.getPrecision());\n        } else if (input.getInputUnits) {\n            for (var i in input.getInputUnits()) {\n                _filterStrokes(input.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n\n        if (input instanceof scope.TextRecognitionInput) {\n            return _doTextRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.ShapeRecognitionInput) {\n            return _doShapeRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MathRecognitionInput) {\n            return _doMathRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MusicRecognitionInput) {\n            return _doMusicRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.AnalyzerRecognitionInput) {\n            return _doAnalyzerRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getUrl(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} url\n     * @param {TextRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.TextRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} url\n     * @param {ShapeRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.ShapeRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} url\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (url, instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} url\n     * @param {MathRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MathRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} url\n     * @param {MusicRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MusicRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} url\n     * @param {AnalyzerRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.AnalyzerRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @deprecated\n     * @method computeHmac\n     * @param {String} applicationKey\n     * @param {String} data\n     * @param {String} hmacKey\n     */\n    AbstractRecognizer.prototype.computeHmac = function (applicationKey, data, hmacKey) {\n        return _computeHmac(data, applicationKey, hmacKey);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.Stroke) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    var _fillData = function (data, input, instanceId, applicationKey, hmacKey) {\n        data.setRecognitionInput(input);\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n","'use strict';\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @constructor\n     */\n    function AbstractWSRecognizer() {\n        this._wsInterface = new scope.NetworkWSInterface();\n    }\n\n    AbstractWSRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'wss://': 'ws://';\n    };\n\n    AbstractWSRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractWSRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractWSRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractWSRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    AbstractWSRecognizer.prototype.setUrl = function (url) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    AbstractWSRecognizer.prototype.getUrl = function () {\n        return this._wsInterface.getUrl();\n    };\n\n    AbstractWSRecognizer.prototype.setCallback = function (callback) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractWSRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractWSRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        if (message.getComponents) {\n            _filterStrokes(message.getComponents(), this.getPrecision());\n        } else if (message.getInputUnits) {\n            for (var i in message.getInputUnits()) {\n                _filterStrokes(message.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(_computeHmac(challenge, applicationKey, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {String} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.Stroke) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript, CryptoJS);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, inputUnits, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.TextRecognitionInput();\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    TextWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/text');\n        }\n    };\n\n    TextWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.TextResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (inputUnits, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (inputUnits, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.ShapeRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MathRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.MathParameter();\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    MathWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/math');\n        }\n    };\n\n    MathWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.MathResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MusicRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n        this.points = [];\n        this.drawing = false;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * Set the context (legacy code for non-regression)\n     *\n     * @private\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype._setContext = function (context) {\n        this.context = context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponents = function (components, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponent = function (component, context, parameters) {\n        if (component instanceof scope.Stroke) {\n            this.drawStroke(component, context, parameters);\n        } else if (component instanceof scope.CharacterInputComponent) {\n            this.drawCharacter(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @method drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRectangle = function (rectangle, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n\n        var params = this.getParameters();\n        this.getContext().save();\n        try {\n            this.getContext().fillStyle = params.getRectColor();\n            this.getContext().strokeStyle = params.getColor();\n            this.getContext().lineWidth = 0.5 * params.getWidth();\n            this.getContext().fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            this.getContext().restore();\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method drawStroke\n     * @param {Stroke} stroke\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStroke = function (stroke, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (stroke && stroke.getLength() > 0) {\n            if (stroke instanceof scope.StrokeComponent) {\n                _renderStroke(stroke, this.getContext());\n            } else {\n                this.drawStart(stroke.getX()[0], stroke.getY()[0]);\n                for (var i = 0; i < stroke.getLength(); ++i) {\n                    this.drawContinue(stroke.getX()[i], stroke.getY()[i], context, parameters);\n                }\n                this.drawEnd(stroke.getX()[stroke.getLength() - 1], stroke.getY()[stroke.getLength() - 1], context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw stroke components\n     *\n     * @private\n     * @method drawStrokes\n     * @param {Stroke[]} strokes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStrokes = function (strokes, context, parameters) {\n        for (var i = 0; i < strokes.length; i++) {\n            this.drawStroke(strokes[i], context, parameters);\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    /**\n     * DEPRECATED METHODS\n     */\n\n    /**\n     * Record the beginning of drawing\n     *\n     * @deprecated\n     * @method drawStart\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStart = function (x, y, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        this.points = [];\n        this.drawing = true;\n        this.points.push(new scope.QuadraticPoint({x: x, y: y}));\n    };\n\n    /**\n     * Record the drawing\n     *\n     * @deprecated\n     * @method drawContinue\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawContinue = function (x, y, context, parameters) {\n        if (this.drawing) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            var params = this.getParameters();\n            var delta = 2 + (params.getWidth() / 4);\n            var last = this.points[this.points.length - 1];\n\n            if (Math.abs(last.getX() - x) >= delta || Math.abs(last.getY() - y) >= delta) {\n\n                if (this.points.length === 1) { // firstPoint\n\n                    var pA = this.points[this.points.length - 1]; // firstPoint\n                    var pB = new scope.QuadraticPoint({x: x, y: y});\n                    var pAB = new scope.QuadraticPoint({\n                        x: 0.5 * (pA.getX() + pB.getX()),\n                        y: 0.5 * (pA.getY() + pB.getY())\n                    });\n                    _computePointParameters(pA, pAB, params.getPressureType());\n                    _computePointParameters(pAB, pB, params.getPressureType());\n\n                    _computeFirstControls(pA, pAB, params.getWidth());\n                    _computeControls(pAB, pB, params.getWidth());\n\n                    this.points.push(pAB);\n                    this.points.push(pB);\n\n                    _drawFirstSegment(pA, pAB, this.getContext(), params);\n\n                } else {\n                    var pAB = this.points[this.points.length - 2]; // jshint ignore:line\n                    var pB = this.points[this.points.length - 1]; // jshint ignore:line\n                    var pC = new scope.QuadraticPoint({x: x, y: y});\n                    var pBC = new scope.QuadraticPoint({\n                        x: 0.5 * (pB.getX() + pC.getX()),\n                        y: 0.5 * (pB.getY() + pC.getY())\n                    });\n                    _computePointParameters(pB, pBC, params.getPressureType());\n                    _computePointParameters(pBC, pC, params.getPressureType());\n\n                    _computeControls(pB, pBC, params.getWidth());\n                    _computeControls(pBC, pC, params.getWidth());\n\n                    this.points.push(pBC);\n                    this.points.push(pC);\n\n                    _drawSegment(pAB, pB, pBC, this.getContext(), params);\n                }\n            }\n        }\n    };\n\n    /**\n     * Stop record of drawing\n     *\n     * @deprecated\n     * @method drawEnd\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawEnd = function (x, y, context, parameters) {\n        if (this.drawing) {\n            var params = this.getParameters();\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            if (this.points.length === 1) {\n                _drawPoint(new scope.QuadraticPoint({x: x, y: y}), this.getContext(), params);\n            } else if (this.points.length > 1) {\n                var pA = this.points[this.points.length - 1];\n                var pB = new scope.QuadraticPoint({x: x, y: y});\n                var pAB = new scope.QuadraticPoint({\n                    x: 0.5 * (pA.getX() + pB.getX()),\n                    y: 0.5 * (pA.getY() + pB.getY())\n                });\n                _computePointParameters(pA, pAB, params.getPressureType());\n                _computePointParameters(pAB, pB, params.getPressureType());\n\n                _computeControls(pA, pAB, params.getWidth());\n                _computeLastControls(pB, params.getWidth());\n\n                this.points.push(pAB);\n                this.points.push(pB);\n\n                _drawLastSegment(pAB, pB, this.getContext(), params);\n            }\n            this.drawing = false;\n        }\n    };\n\n    /**\n     * Draw point on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawPoint\n     * @param {QuadraticPoint} point\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawPoint = function (point, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.arc(point.getX(), point.getY(), 0.25 * parameters.getWidth(), 0, 2 * Math.PI);\n            context.fill();\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw the first stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawFirstSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawFirstSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw middle stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {QuadraticPoint} pC\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawSegment = function (pA, pB, pC, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.quadraticCurveTo(pB.getP1().getX(), pB.getP1().getY(), pC.getP1().getX(), pC.getP1().getY());\n            context.lineTo(pC.getP2().getX(), pC.getP2().getY());\n            context.quadraticCurveTo(pB.getP2().getX(), pB.getP2().getY(), pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw the last stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawLastSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLastSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Compute distance and unit vector from the previous point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePointParameters\n     * @param {QuadraticPoint} previous\n     * @param {QuadraticPoint} point\n     * @param {String} pressureType\n     */\n    var _computePointParameters = function (previous, point, pressureType) {\n        var dx = point.getX() - previous.getX(),\n            dy = point.getY() - previous.getY(),\n            d = Math.sqrt((dx * dx) + (dy * dy));\n\n        if (d !== 0) {\n            point.setDistance(d);\n            point.setCos(dx / d);\n            point.setSin(dy / d);\n        }\n        point.setLength(previous.getLength() + point.getDistance());\n\n        switch (pressureType) {\n            case 'SIMULATED':\n                _computePressure(point);\n                break;\n            case 'CONSTANT':\n                point.setPressure(1.0);\n                break;\n            case 'REAL':\n                // keep the current pressure\n                break;\n            default:\n                throw new Error('Unknown pressure type');\n        }\n    };\n\n    /**\n     * Compute simulated pressure of given point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePressure\n     * @param {QuadraticPoint} point\n     */\n    var _computePressure = function (point) {\n        var k, pressure;\n        if (point.getDistance() < 10) {\n            k = 0.2 + Math.pow(0.1 * point.getDistance(), 0.4);\n        } else if (point.getDistance() > point.getLength() - 10) {\n            k = 0.2 + Math.pow(0.1 * (point.getLength() - point.getDistance()), 0.4);\n        } else {\n            k = 1.0;\n        }\n\n        pressure = k * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(point.getDistance()));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        point.setPressure(pressure);\n    };\n\n    /**\n     * Compute control points of the first point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeFirstControls\n     * @param {QuadraticPoint} first First point of the list to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeFirstControls = function (first, next, penWidth) {\n        var r = 0.5 * (penWidth * first.getPressure()),\n            nx = r * next.getSin(),\n            ny = r * next.getCos();\n\n        first.getP1().setX(first.getX() - nx);\n        first.getP1().setY(first.getY() + ny);\n        first.getP2().setX(first.getX() + nx);\n        first.getP2().setY(first.getY() - ny);\n    };\n\n    /**\n     * Compute control points between two points.\n     *\n     * @private\n     * @deprecated\n     * @method _computeControls\n     * @param {QuadraticPoint} point Point to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeControls = function (point, next, penWidth) {\n        var cos = point.getCos() + next.getCos(),\n            sin = point.getSin() + next.getSin(),\n            u = Math.sqrt((cos * cos) + (sin * sin));\n\n        if (u !== 0) {\n            // compute control points\n            var r = 0.5 * penWidth * point.getPressure();\n            var nx = -r * sin / u;\n            var ny = r * cos / u;\n            point.getP1().setX(point.getX() + nx);\n            point.getP1().setY(point.getY() + ny);\n            point.getP2().setX(point.getX() - nx);\n            point.getP2().setY(point.getY() - ny);\n        }\n    };\n\n    /**\n     * Compute control points of the last point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeLastControls\n     * @param {QuadraticPoint} last Last point to be computed\n     * @param {Number} penWidth Pen width\n     */\n    var _computeLastControls = function (last, penWidth) {\n        var r = 0.5 * penWidth * last.getPressure(),\n            nx = -r * last.getSin(),\n            ny = r * last.getCos();\n\n        last.getP1().setX(last.getX() + nx);\n        last.getP1().setY(last.getY() + ny);\n        last.getP2().setX(last.getX() - nx);\n        last.getP2().setY(last.getY() - ny);\n    };\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (inputUnits, recognitionResult, context, parameters) {\n        this.drawInputUnits(inputUnits, context, parameters);\n    };\n\n    /**\n     * Draw input units\n     *\n     * @method drawInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawInputUnits = function (inputUnits, context, parameters) {\n        for (var i in inputUnits) {\n            this.drawComponents(inputUnits[i].getComponents(), context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @deprecated\n     * @method drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawTextComponent = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawTextComponent(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (this.isTypesetting()) {\n            this.drawShapes(components, recognitionResult.getSegments(), context, parameters);\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes, context, parameters) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawShapeNotRecognized(components, segment.getInkRanges(), context, parameters);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @deprecated\n     * @method drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeRecognized(shapeRecognized, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges, context, parameters) {\n        var notRecognized = _extractShapeNotRecognized(components, inkRanges);\n        this.drawComponents(notRecognized, context, parameters);\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @deprecated\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @deprecated\n     * @method drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeLine = function (shapeLine, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeLine(shapeLine, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @deprecated\n     * @method drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeEllipse(shapeEllipse, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Get strokes from shape inkRange\n     *\n     * @deprecated\n     * @method extractStroke\n     * @param {Stroke[]} strokes\n     * @param {ShapeInkRange} inkRange\n     * @result {Stroke[]} List of strokes from inkRange\n     */\n    ShapeRenderer.prototype.extractStroke = function (strokes, inkRange) {\n        return _extractShapeNotRecognized(strokes, inkRange);\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {*}\n     */\n    var _extractShapeNotRecognized = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.Stroke(), x = [], y = [];\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    x.push(currentStroke.getX()[pointIndex]);\n                    y.push(currentStroke.getY()[pointIndex]);\n                }\n\n                newStroke.setX(x);\n                newStroke.setY(y);\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMathScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MathScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MathRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMathScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMathScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getErasedInkRanges()[n].getComponent());\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getInkRanges()[p].getComponent());\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MusicScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MusicRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMusicScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawStaff = function (staff, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw music node\n     *\n     * @method drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawMusicNode = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawMusicNode(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (this.isTypesetting()) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes(), context, parameters);\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component, context, parameters);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @deprecated\n     * @method drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTables = function (components, tables, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in tables) {\n            if (this.getShowBoundingBoxes()) {\n                for (var j in tables[i].getCells()) {\n                    _drawCell(tables[i].getCells()[j], this.getContext(), this.getParameters());\n                }\n            }\n        }\n        _drawTables(components, tables, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @deprecated\n     * @method drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTextLines = function (components, textLines, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data && this.getShowBoundingBoxes()) {\n                this.drawRectangle(data.getBoundingBox(), context, parameters);\n            }\n        }\n        _drawTextLines(components, textLines, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @deprecated\n     * @method drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawText(boundingBox, text, justificationType, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Underline\n     *\n     * @deprecated\n     * @method drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawUnderline(boundingBox, underline, text, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @deprecated\n     * @method drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        _drawGroups(components, groups, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @deprecated\n     * @method drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n            _drawCell(cell, this.getContext(), this.getParameters());\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Image Renderer. It's used to calculate the Image ink rendering in HTML5 canvas\n     *\n     * @class ImageRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ImageRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ImageRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ImageRenderer.prototype.constructor = ImageRenderer;\n\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ImageRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                console.log(components)\n                console.log(typeof component)\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    // Export\n    scope.ImageRenderer = ImageRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n","'use strict';\n'use strict';\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n        this.canvasRatio = 1;\n\n        // Capture\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n        this.canvasRatio = _getCanvasRatio(this._renderingCanvas);\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer();\n        this._mathRecognizer = new scope.MathRecognizer();\n        this._shapeRecognizer = new scope.ShapeRecognizer();\n        this._musicRecognizer = new scope.MusicRecognizer();\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer();\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this));\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this));\n\n        this._attachListeners(element);\n\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            ssl: true,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        // Recognition type\n        this.setType(this.options.type);\n\n        this.setHost(this.options.host);\n        this.setSSL(this.options.ssl);\n\n        this.setTextParameters(this.options.textParameters); // jshint ignore:line\n        this.setMathParameters(this.options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(this.options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(this.options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(this.options.analyzerParameters); // jshint ignore:line\n\n        this.setProtocol(this.options.protocol);\n        this.setTimeout(this.options.timeout);\n        this.setApplicationKey(this.options.applicationKey);\n        this.setHmacKey(this.options.hmacKey);\n\n        this.setPenParameters(this.options.penParameters);\n\n        this.setPrecision(this.options.precision);\n        this.setTypeset(this.options.typeset);\n        this.setComponents(this.options.components);\n\n        this.setWidth(this.options.width);\n        this.setHeight(this.options.height);\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        if(width > 0){\n            this._captureCanvas.width = width * this.canvasRatio;\n            this._captureCanvas.style.width = width + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.width = width * this.canvasRatio;\n            this._renderingCanvas.style.width = width + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        if(height > 0){\n            this._captureCanvas.height = height * this.canvasRatio;\n            this._captureCanvas.style.height = height + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.height = height * this.canvasRatio;\n            this._renderingCanvas.style.height = height + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Set the recognition precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    InkPaper.prototype.setPrecision = function (precision) {\n        this._textRecognizer.setPrecision(precision);\n        this._textWSRecognizer.setPrecision(precision);\n        this._mathRecognizer.setPrecision(precision);\n        this._mathWSRecognizer.setPrecision(precision);\n        this._shapeRecognizer.setPrecision(precision);\n        this._musicRecognizer.setPrecision(precision);\n        this._analyzerRecognizer.setPrecision(precision);\n    };\n\n    /**\n     * Get the default components\n     *\n     * @method getComponents\n     * @return {Array} components\n     */\n    InkPaper.prototype.getComponents = function () {\n        return this.options.components;\n    };\n\n    /**\n     * Set the default components\n     *\n     * @method setComponents\n     * @param {Array} components\n     */\n    InkPaper.prototype.setComponents = function (components) {\n        this.options.components = components;\n        this._initRenderingCanvas();\n    };\n\n\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @deprecated Use setTextParameters instead\n     * @method setLanguage\n     * @param  String language\n     */\n    InkPaper.prototype.setLanguage = function (language) {\n        if (this.options.type === scope.RecognitionType.TEXT) {\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setLanguage(language);\n        }\n    };\n\n    /**\n     * Set math recognition format result types\n     *\n     * @deprecated Use setMathParameters instead\n     * @method setResultTypes\n     * @param  Array resultTypes\n     */\n    InkPaper.prototype.setResultTypes = function (resultTypes) {\n        if (this.options.type === scope.RecognitionType.MATH) {\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setResultTypes(resultTypes.map(function (x) {\n                return x.toUpperCase();\n            }));\n        }\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n            this._initRenderingCanvas();\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @param {String} [inputMode] input mode\n     */\n    InkPaper.prototype.getAvailableLanguages = function (inputMode) {\n        this._selectedRESTRecognizer.getAvailableLanguageList(\n            this.getApplicationKey(),\n            inputMode ? inputMode : this._textRecognizer.getParameters().getInputMode()\n        ).then(\n            function (data) {\n                this._onResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the recognition callback\n     *\n     * @method setCallback\n     * @deprecated Use setResultCallback instead\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     */\n    InkPaper.prototype.setCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        return this._doRecognition(this.components);\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this.components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            this.redoComponents.push(this.components.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this.redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this.components.push(this.redoComponents.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            if (this._instanceId) {\n                this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                this._instanceId = undefined;\n            }\n        }\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this._inkGrabber.clear();\n        this._instanceId = undefined;\n\n        this._initRenderingCanvas();\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n        var sizeChanged = false;\n        if (this._captureCanvas.clientHeight != this._captureCanvas.height) {\n            this._captureCanvas.height = this._captureCanvas.clientHeight;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight;\n            sizeChanged = true;\n        }\n\n        if (this._captureCanvas.clientWidth != this._captureCanvas.width) {\n            this._captureCanvas.width = this._captureCanvas.clientWidth;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth;\n            sizeChanged = true;\n        }\n\n        //Safari trash the canvas content when heigth or width are modified.\n        if(sizeChanged){\n            this._initRenderingCanvas();\n        }\n\n        if (this.canRedo()) {\n            this.redoComponents = [];\n            this._onChange();\n        }\n\n        this._inkGrabber.startCapture(x, y, t);\n\n\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this.components.push(stroke);\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            }\n        }\n    };\n\n    /**\n     * Do recognition\n     *\n     * @private\n     * @method _doRecognition\n     * @param {AbstractComponent[]} components Input components\n     */\n    InkPaper.prototype._doRecognition = function (components) {\n        if (components.length > 0) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                if (this._initialized) {\n                    var inputWS = [];\n                    if (this._selectedRecognizer instanceof scope.TextWSRecognizer) {\n                        var inputUnitWS = new scope.TextInputUnit();\n                        inputUnitWS.setComponents(this.getComponents().concat(components.slice(this.lastNonRecoComponentIdx)));\n                        inputWS = [inputUnitWS];\n                    } else {\n                        inputWS = components.slice(this.lastNonRecoComponentIdx);\n                    }\n                    this.lastNonRecoComponentIdx = components.length;\n\n\n                    if (this.isStarted) {\n                        this._selectedRecognizer.continueWSRecognition(inputWS, this._instanceId);\n                    } else {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(inputWS);\n                    }\n                }\n            } else {\n                var input = [];\n                if (this._selectedRecognizer instanceof scope.TextRecognizer) {\n                    var inputUnit = new scope.TextInputUnit();\n                    inputUnit.setComponents(this.getComponents().concat(components));\n                    input = [inputUnit];\n                } else if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                    input = components.slice(this.lastNonRecoComponentIdx);\n                    this.lastNonRecoComponentIdx = components.length;\n                } else {\n                    input = input.concat(this.getComponents(), components);\n                }\n                this._selectedRecognizer.doSimpleRecognition(\n                    this.getApplicationKey(),\n                    this._instanceId,\n                    input,\n                    this.getHmacKey()\n                ).then(\n                    function (data) {\n                        this._parseResult(data, input);\n                    }.bind(this),\n                    function (error) {\n                        this._onResult(undefined, error);\n                    }.bind(this)\n                );\n            }\n        } else {\n            this.isStarted = false;\n            this._selectedRenderer.clear();\n            this._initRenderingCanvas();\n            this._onResult();\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('failure', {detail: err})); // FIXME: mark as deprecated\n            this._element.dispatchEvent(new CustomEvent('error', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function () {\n        var data = {\n            canUndo: this.canUndo(),\n            undoLength: this.components.length,\n            canRedo: this.canRedo(),\n            redoLength: this.redoComponents.length\n        };\n\n        if (this.changeCallback) {\n            this.changeCallback(data)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: data}));\n    };\n\n    InkPaper.prototype._parseResult = function (data, input) {\n\n        if (!this._instanceId) {\n            this._instanceId = data.getInstanceId();\n        } else if (this._instanceId !== data.getInstanceId()) {\n            this._onResult(data);\n            return data;\n        }\n\n        if (data.getDocument().hasScratchOutResults() || this._selectedRenderer.isTypesetting()) {\n            this._selectedRenderer.clear();\n            this._selectedRenderer.drawRecognitionResult(input, data.getDocument());\n        }\n\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service url\n     *\n     * @param {String} host\n     */\n    InkPaper.prototype.setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._textWSRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._mathWSRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * @private\n     */\n    InkPaper.prototype.setSSL = function (ssl) {\n        this._textRecognizer.setSSL(ssl);\n        this._textWSRecognizer.setSSL(ssl);\n        this._mathRecognizer.setSSL(ssl);\n        this._mathWSRecognizer.setSSL(ssl);\n        this._shapeRecognizer.setSSL(ssl);\n        this._musicRecognizer.setSSL(ssl);\n        this._analyzerRecognizer.setSSL(ssl);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n\n        //Desactivation of contextmenu to prevent safari to fire pointerdown only once\n        element.addEventListener(\"contextmenu\", function(e){\n            e.preventDefault();\n            e.stopPropagation();\n            return false; }\n        );\n\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n        this._drawInput(this.components);\n    };\n\n    InkPaper.prototype._drawInput = function (components) {\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        this._selectedRenderer.drawComponents(this.getComponents().concat(components));\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this.lastNonRecoComponentIdx = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge(this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    break;\n                default:\n                    this._parseResult(message, this.components);\n                    break;\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Return the stats allowing to monitor what ink size is send to the server.\n     * @returns Stats objects format {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'} humanUnit could have the values BYTE, BYTES, KiB, MiB\n     */\n    InkPaper.prototype.getStats = function () {\n        var stats = {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'};\n        if(this.components){\n            stats.strokesCount = this.components.length;\n            var pointsCount = 0;\n            for(var strokeNb = 0; strokeNb < this.components.length; strokeNb++){\n                pointsCount = pointsCount + this.components[strokeNb].x.length;\n            }\n            stats.strokesCount = this.components.length;\n            stats.pointsCount = pointsCount;\n            //We start with 270 as it is the size in bytes. Make a real computation implies to recode a doRecogntion\n            var byteSize = 270;\n            byteSize = JSON.stringify(this.components).length;\n            stats.byteSize = byteSize;\n            if (byteSize < 270) {\n                stats.humanUnit = 'BYTE';\n                stats.byteSize = 0;\n                stats.humanSize  = 0;\n            } else if (byteSize < 2048) {\n                stats.humanUnit = 'BYTES';\n                stats.humanSize  = byteSize;\n            } else if (byteSize < 1024 * 1024) {\n                stats.humanUnit = 'KiB';\n                stats.humanSize = (byteSize / 1024).toFixed(2);\n            } else {\n                stats.humanUnit = 'MiB';\n                stats.humanSize = (byteSize / 1024 / 1024).toFixed(2);\n            }\n        }\n        return stats;\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {ImageData} Build an ImageData object with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsImageData = function (marginX, marginY) {\n        if(!marginX){\n            marginX = 10;\n        }\n        if(!marginY){\n            marginY = 10;\n        }\n        console.log({marginX : marginX, marginY : marginY});\n        if(this.components && this.components.length > 0){\n            var updatedStrokes ;\n            var strokesCount = this.components.length;\n            //Initializing min and max\n            var minX = this.components[0].x[0];\n            var maxX = this.components[0].x[0];\n            var minY = this.components[0].y[0];\n            var maxY = this.components[0].y[0];\n            // Computing the min and max for x and y\n            for(var strokeNb = 0; strokeNb < this.components.length; strokeNb++){\n                var pointCount = this.components[strokeNb].x.length;\n                for(var pointNb = 0; pointNb < pointCount; pointNb ++){\n                    var currentX = this.components[strokeNb].x[pointNb];\n                    var currentY = this.components[strokeNb].y[pointNb];\n                    if(currentX < minX){\n                        minX = currentX;\n                    }\n                    if(currentX > maxX){\n                        maxX = currentX;\n                    }\n                    if(currentY < minY){\n                        minY = currentY;\n                    }\n                    if(currentY > maxY){\n                        maxY = currentY;\n                    }\n                }\n            }\n            var nonDisplayCanvas = document.createElement('canvas');\n            nonDisplayCanvas.width = (maxX )+(2*marginX);\n            nonDisplayCanvas.height = (maxY )+(2*marginY)\n\n            var ctx =  nonDisplayCanvas.getContext(\"2d\");\n\n            var imageRendered = new scope.ImageRenderer(ctx);\n            imageRendered.drawComponents(this.components, ctx);\n\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData\n            var imageData = ctx.getImageData(minX-marginX, minY-marginY, (maxX-minX )+(2*marginX), (maxY-minY )+(2*marginY));\n            return imageData;\n        } else {\n            return;\n        }\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {String} Build an String containg dataUrl with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsPng = function (marginX, marginY) {\n        var imageRenderingCanvas = document.createElement('canvas');\n        imageRenderingCanvas.style.display = 'none';\n\n        var imageDataToRender = this.getInkAsImageData();\n        imageRenderingCanvas.width = imageDataToRender.width;\n        imageRenderingCanvas.style.width = imageDataToRender.width +'px';\n        imageRenderingCanvas.height = imageDataToRender.height;\n        imageRenderingCanvas.style.height = imageDataToRender.height +'px';\n        var ctx = imageRenderingCanvas.getContext('2d');\n        ctx.putImageData(imageDataToRender, 0, 0);\n        var ret = imageRenderingCanvas.toDataURL(\"image/png\");\n        return ret;\n    }\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n    /**\n     * Tool to get canvas ratio (retina display)\n     *\n     * @private\n     * @param {Element} canvas\n     * @returns {Number}\n     */\n    function _getCanvasRatio(canvas) {\n        if (canvas) {\n            var context = canvas.getContext('2d'),\n                devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                    context.mozBackingStorePixelRatio ||\n                    context.msBackingStorePixelRatio ||\n                    context.oBackingStorePixelRatio ||\n                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        }\n        return 1;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n"],"sourceRoot":"/source/"}